<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java-web学习 MyBatis</title>
      <link href="/2022/12/11/java-web%E5%AD%A6%E4%B9%A0-MyBatis/"/>
      <url>/2022/12/11/java-web%E5%AD%A6%E4%B9%A0-MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>MyBatis是一款优秀的<code>持久层框架</code>,用于简化JDBC开发</li><li>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></li></ul><h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>参照官方文档：<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p><ul><li><p>安装</p><pre><code>&lt;dependency&gt;&lt;groupId&gt;org.mybatis&lt;/groupId&gt;&lt;artifactId&gt;mybatis&lt;/artifactId&gt;&lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>创建存放<code>xxxMapper.java</code>的包<code>com.xxx.mapper</code></p></li><li><p>在resources下面创建和<code>com.xxx.mapper</code>对应的存放<code>xxxMapper.xml</code>的文件夹<code>com.xxx.mapper</code>（注意这里创建的时候应该输入的是<code>com/xxx/mapper</code>而不是<code>com.xxx.mapper</code>），这样编译后<code>xxxMapper.class</code>就会和<code>xxxMapper.xml</code>保存在一个文件夹下面，从而符合mybatis的规范。</p></li><li><p>在resources下面创建mybatis-config.xml文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt;      &lt;environment id=&quot;development&quot;&gt;          &lt;transactionManager type=&quot;JDBC&quot;/&gt;          &lt;dataSource type=&quot;POOLED&quot;&gt;              &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;              &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;              &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;              &lt;property name=&quot;password&quot; value=&quot;12345678&quot;/&gt;          &lt;/dataSource&gt;      &lt;/environment&gt;  &lt;/environments&gt;&lt;mappers&gt;  &lt;!-- 我们自己存放mapper的包名 --&gt;  &lt;package name=&quot;com.xxx.mapper&quot;/&gt;&lt;/mappers&gt;&lt;/configuration&gt;</code></pre></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>创建<code>User.java</code><br>```<br>package com.mybatis.pojo;</li></ul><p>public class User {<br>    private Integer id;<br>    private String username;<br>    private String password;<br>    private String companyName;<br>    private String gender;<br>    private String addr;</p><pre><code>public Integer getId() &#123;    return id;&#125;public void setId(Integer id) &#123;    this.id = id;&#125;public String getUsername() &#123;    return username;&#125;public void setUsername(String username) &#123;    this.username = username;&#125;public String getPassword() &#123;    return password;&#125;public void setPassword(String password) &#123;    this.password = password;&#125;public String getCompanyName() &#123;    return companyName;&#125;public void setCompanyName(String companyName) &#123;    this.companyName = companyName;&#125;public String getGender() &#123;    return gender;&#125;public void setGender(String gender) &#123;    this.gender = gender;&#125;public String getAddr() &#123;    return addr;&#125;public void setAddr(String addr) &#123;    this.addr = addr;&#125;@Overridepublic String toString() &#123;    return &quot;User&#123;&quot; +            &quot;id=&quot; + id +            &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +            &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +            &quot;, companyName=&#39;&quot; + companyName + &#39;\&#39;&#39; +            &quot;, gender=&#39;&quot; + gender + &#39;\&#39;&#39; +            &quot;, addr=&#39;&quot; + addr + &#39;\&#39;&#39; +            &#39;&#125;&#39;;&#125;</code></pre><p>}</p><pre><code>+ 创建`UserMapper.java`</code></pre><p>package com.mybatis.mapper;</p><p>import com.mybatis.pojo.User;<br>import org.apache.ibatis.annotations.Param;</p><p>import java.util.List;</p><p>public interface UserMapper {</p><pre><code>List&lt;User&gt; selectAll();// 如果单独传参数的话需要指定参数名字，这样在UserMapper.xml那边才能通过#&#123;id&#125;的方式使用User selectById(@Param(&quot;id&quot;) int id);// 如果传入的是User，这样在UserMapper.xml那边能通过#&#123;id&#125;的方式使用List&lt;User&gt; selectUser(User user);// 如果添加了参数名字，这样在UserMapper.xml那边能通过#&#123;user.id&#125;的方式使用// List&lt;User&gt; selectUser(@Param(&quot;user&quot;) User user);void addUser(User user);void modifyUser(User user);void deleteById(@Param(&quot;id&quot;) int id);</code></pre><p>}</p><pre><code>+ 创建`UserMapper.xml`</code></pre><?xml version="1.0" encoding="UTF-8" ?><!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "https://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="mybatis.mapper.UserMapper">    <!--  本地user的companyName和数据库储存的不对应，这里做转换  -->    <resultMap id="userResultMap" type="com.mybatis.pojo.User">        <result column="company_name" property="companyName"/>    </resultMap>    <select id="selectAll" resultType="com.mybatis.pojo.User">        select * from user;    </select>    <select id="selectById" resultType="com.mybatis.pojo.User">        select * from user where id = #{id};    </select>    <select id="selectUser" resultMap="userResultMap">        select *        from user        <where>            <if test="username != null and username != ''">                and username = #{username}            </if>            <if test="password != null and password != ''">                and password = #{password}            </if>            <if test="companyName != null and companyName != ''">                and company_name = #{companyName}            </if><pre><code>        &lt;if test=&quot;gender != null and gender != &#39;&#39;&quot;&gt;            and gender = #&#123;gender&#125;        &lt;/if&gt;        &lt;if test=&quot;addr != null and addr != &#39;&#39;&quot;&gt;            and addr = #&#123;addr&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;&lt;insert id=&quot;addUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into user(username,password,company_name,gender,addr)    values(#&#123;username&#125;,#&#123;password&#125;,#&#123;companyName&#125;,#&#123;gender&#125;,#&#123;addr&#125;)&lt;/insert&gt;&lt;update id=&quot;modifyUser&quot;&gt;    update user    &lt;set&gt;        &lt;if test=&quot;username != null and username != &#39;&#39;&quot;&gt;            username = #&#123;username&#125;,        &lt;/if&gt;        &lt;if test=&quot;password != null and password != &#39;&#39;&quot;&gt;            password = #&#123;password&#125;,        &lt;/if&gt;        &lt;if test=&quot;companyName != null and companyName != &#39;&#39;&quot;&gt;            company_name = #&#123;companyName&#125;,        &lt;/if&gt;        &lt;if test=&quot;gender != null and gender != &#39;&#39;&quot;&gt;            gender = #&#123;gender&#125;,        &lt;/if&gt;        &lt;if test=&quot;addr != null and addr != &#39;&#39;&quot;&gt;            addr = #&#123;addr&#125;,        &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id=&quot;deleteById&quot;&gt;    delete from user where id = #&#123;id&#125;&lt;/delete&gt;</code></pre></mapper>```<ul><li>使用<code>UserMapper.java</code>的方法<br>```<br>package com.mybatis.test;</li></ul><p>import com.mybatis.mapper.UserMapper;<br>import com.mybatis.pojo.User;<br>import org.apache.ibatis.io.Resources;<br>import org.apache.ibatis.session.SqlSession;<br>import org.apache.ibatis.session.SqlSessionFactory;<br>import org.apache.ibatis.session.SqlSessionFactoryBuilder;<br>import org.junit.Test;</p><p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.util.List;</p><p>public class MyBatisTest {<br>    @Test<br>    public void selectALl() throws IOException {<br>        String resource = “mybatis-config.xml”;<br>        InputStream inputStream = Resources.getResourceAsStream(resource);<br>        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder(). build(inputStream);<br>        SqlSession sqlSession = sqlSessionFactory.openSession();<br>        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>        List<User> users = userMapper.selectAll();<br>        System.out.println(users);<br>    }</p><pre><code>@Testpublic void selectById() throws IOException &#123;    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder(). build(inputStream);    SqlSession sqlSession = sqlSessionFactory.openSession();    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    User user = userMapper.selectById(1);    System.out.println(user);&#125;@Testpublic void selectUser() throws IOException &#123;    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder(). build(inputStream);    SqlSession sqlSession = sqlSessionFactory.openSession();    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    User user = new User();    user.setUsername(&quot;zl&quot;);    user.setPassword(&quot;123&quot;);    user.setAddr(&quot;cd&quot;);    user.setGender(&quot;nan&quot;);    user.setCompanyName(&quot;lp&quot;);    List&lt;User&gt; users = userMapper.selectUser(user);    System.out.println(users);&#125;@Testpublic void addUser() throws IOException &#123;    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder(). build(inputStream);    SqlSession sqlSession = sqlSessionFactory.openSession(true);    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    User user = new User();    user.setUsername(&quot;zll&quot;);    user.setPassword(&quot;123&quot;);    user.setAddr(&quot;cd&quot;);    user.setGender(&quot;nan&quot;);    user.setCompanyName(&quot;lp&quot;);    userMapper.addUser(user);    System.out.println(user.getId());&#125;@Testpublic void modifyById() throws IOException &#123;    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder(). build(inputStream);    SqlSession sqlSession = sqlSessionFactory.openSession(true);    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    User user = new User();    user.setId(1);    user.setUsername(&quot;zlxl&quot;);    user.setAddr(&quot;xxx2&quot;);    user.setGender(&quot;xxx3&quot;);    user.setCompanyName(&quot;xxx4&quot;);    userMapper.modifyUser(user);&#125;@Testpublic void deleteById() throws IOException &#123;    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder(). build(inputStream);    SqlSession sqlSession = sqlSessionFactory.openSession(true);    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    userMapper.deleteById(2);&#125;</code></pre><p>}</p><pre><code></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-web学习 MySQL</title>
      <link href="/2022/11/20/java-web%E5%AD%A6%E4%B9%A0-MySQL/"/>
      <url>/2022/11/20/java-web%E5%AD%A6%E4%B9%A0-MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><h3 id="数据库（DB）"><a href="#数据库（DB）" class="headerlink" title="数据库（DB）"></a>数据库（DB）</h3><p>储存数据的仓库，数据是有组织的进行储存的</p><h3 id="数据库管理系统（DBMS：DateBase-Manager-Server）"><a href="#数据库管理系统（DBMS：DateBase-Manager-Server）" class="headerlink" title="数据库管理系统（DBMS：DateBase Manager Server）"></a>数据库管理系统（DBMS：DateBase Manager Server）</h3><p>管理数据库的软件（Oracle，MySQL，sqlite等等都是数据库管理系统）</p><h3 id="SQL（Structured-Queue-Language）"><a href="#SQL（Structured-Queue-Language）" class="headerlink" title="SQL（Structured Queue Language）"></a>SQL（Structured Queue Language）</h3><ul><li>结构化查询语言</li><li>操作关系型数据库的编程语言</li><li>定义操作所有类型数据库的统一标准</li></ul><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>通过表来储存数据的数据库</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>结构化查询语言</li><li>操作关系型数据库的编程语言</li><li>定义操作所有类型数据库的统一标准</li><li>不同数据库会存在不同用法（方言）</li></ul><h3 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h3><ul><li>可以单行多行书写，以分号（;）结尾</li><li>语句不区分大小写</li><li>注释<ul><li>单行注释：<code>-- 注释内容</code> 或 <code>#注释内容</code>（MySQL特有）</li><li>多行注释：<code>/* 注释 */</code></li></ul></li></ul><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><h4 id="DDL（Data-Definition-Language）数据定义语言-操作数据库，表等"><a href="#DDL（Data-Definition-Language）数据定义语言-操作数据库，表等" class="headerlink" title="DDL（Data Definition Language）数据定义语言 操作数据库，表等"></a>DDL（Data Definition Language）数据定义语言 操作数据库，表等</h4><ul><li>show databases; // 查看所有数据库</li><li>create database db1; // 创建一个名字为db1的数据库</li><li>create database if not exists db1; // 创建一个名字为db1的数据库，如果它不存在的话</li><li>drop database db1; // 删除一个名字为db1的数据库</li><li>drop database if exists db1; // 删除一个名字为db1的数据库，如果它存在的话</li><li>use db1; // 使用db1</li><li>select database(); // 查看当前使用的数据库</li><li>show tables; // 查看所有表</li><li>desc user; // 查看user表的结构</li><li>create table user(id int,username varchar(20),password varchar(32)); // 创建一个名字为table1的表</li><li>drop table user; // 删除一个名字位user的表</li><li>drop table if exists user; // 删除一个名字位user的表，如果它存在的话</li><li>alter table user rename to tb_user; // 修改user表的名字为tb_user</li><li>alter table user add age int; // 给user表新增一列（age）</li><li>alert table user modify name varchar(20); // 修改列的类型</li><li>alter table user change name username varchar(20); // 修改列的名字和类型 name改为username 类型改为varchar(20)</li><li>alter table user drop username; // 删除列</li></ul><h5 id="常用的数据类型"><a href="#常用的数据类型" class="headerlink" title="常用的数据类型"></a>常用的数据类型</h5><ul><li>int // age int</li><li>double // score double(总长度,保留小数点后多少位) 比如0～100保留2位小数 double(5,2)</li><li>date // birthday date</li><li>char // 定长字符串 name char(10) 存”张三” 占用10个字符空间 储存性能高 浪费空间</li><li>varchar// 变长字符串 name varchar(10) 存”张三” 占用2个字符空间 储存性能低 节约空间</li></ul><h4 id="DML（Data-Manipulation-Language）数据操作语言-对表中的数据进行增删改"><a href="#DML（Data-Manipulation-Language）数据操作语言-对表中的数据进行增删改" class="headerlink" title="DML（Data Manipulation Language）数据操作语言 对表中的数据进行增删改"></a>DML（Data Manipulation Language）数据操作语言 对表中的数据进行增删改</h4><ul><li>insert into user(id,name) values(1,”zl”); // 给指定列插入数据</li><li>insert into user values(1,”zl”); // 给所有列添加数据，列名的列表是可以省略的</li><li>insert into user values(1,”zl”),(1,”zl”),(1,”zl”),(1,”zl”); // 插入多行</li><li>update user set username = “zs” where username = “zl”; // 把username为zl的username修改为zs</li><li>update user set username = “zs”; // 没有where条件判断 会修改所有数据</li><li>delete from user where username = “zl”; // 删除username为zl的数据</li><li>delete from user; // 没有where条件判断 会删除所有数据</li></ul><h4 id="DQL（Data-Query-Language）数据查询语言-对表中的数据进行查询"><a href="#DQL（Data-Query-Language）数据查询语言-对表中的数据进行查询" class="headerlink" title="DQL（Data Query Language）数据查询语言 对表中的数据进行查询"></a>DQL（Data Query Language）数据查询语言 对表中的数据进行查询</h4><p>select 字段名称 from 表名 where 条件列表 group by 分支字段 having 分组后的条件 order by 排序字段 limit 分页限定</p><h5 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h5><ul><li>select * from user; // 查询user的所有数据</li><li>select username from user; // 查询user的username列</li><li>select distinct address from user; // 去重查询</li><li>select username as 名字 from user; // 给列取别名</li></ul><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><ul><li>select * from user where age = 45; // 年龄45的</li><li>select * from user where age != 45; // 年龄不为45的</li><li>select * from user where age &lt;&gt; 45; // 年龄不为45的</li><li>select * from user where age &gt;= 45; // 年龄大于等于45的</li><li>select * from user where age &gt; 45 &amp;&amp; age &lt; 60; // 年龄在45到60之间的</li><li>select * from user where age &gt; 45 and age &lt; 60; // 年龄在45到60之间的</li><li>select * from user where age between 45 and 60; // 年龄在45到60之间的（边界要取）</li><li>select * from user where age = 45 or age = 60; // 年龄是45或者60</li><li>select * from user where age = 45 || age = 60; // 年龄是45或者60</li><li>select * from user where age in (45,60); // 年龄是45或者60</li><li>select * from user where english is null; // 查询english为null的数据</li><li>select * from user where english is not null; // 查询english不为null的数据</li><li>select * from user where name like “马%”; // 查询姓马的的人 %匹配多个字符</li><li>select * from user where name like “马%疼”; // 查询名字为马*疼的人</li><li>select * from user where name like “_花%”; // 查询第二个字是花的人 _匹配单个字符</li></ul><h5 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h5><ul><li>select * from user order by age asc; // 升序排列</li><li>select * from user order by age desc; // 降序排列</li><li>select * from user order by math desc , english desc; // 多个排列条件</li></ul><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><ul><li>select count(id) from user; // count统计数量，列不为null都会纳入计算</li><li>select max(id) from user; // 最大，列不为null都会纳入计算</li><li>select min(id) from user; // 最小，列不为null都会纳入计算</li><li>select sum(id) from user; // 总和，列不为null都会纳入计算</li><li>select avg(id) from user; // 平均，列不为null都会纳入计算</li><li>todo 其他函数</li></ul><h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><ul><li>select sex, avg(math) from user group by sex; // 查询不同性别数学的平均分</li><li>select sex, avg(math), count(*) from user group by sex; // 查询不同性别数学的平均分以及各自人数</li><li>select sex, avg(math), count(*) from user where math &gt; 90 group by sex; // 查询不同性别数学的平均分以及各自人数，要求分数低于90的算到分组内</li><li>select sex, avg(math), count(*) from user where math &gt; 90 group by sex having avg(math) &gt; 95; // 查询不同性别数学的平均分以及各自人数，要求分数低于90的算到分组内，且分组后平均分大于95的</li></ul><h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h5><ul><li>select * from user limit 1,3; // limit start,length 从2个开始查3个数</li><li>select * from user limit 3; // 从第一个开始 查3个数</li></ul><h4 id="DCL（Data-Control-Language）数据控制语言-对数据进行权限控制"><a href="#DCL（Data-Control-Language）数据控制语言-对数据进行权限控制" class="headerlink" title="DCL（Data Control Language）数据控制语言 对数据进行权限控制"></a>DCL（Data Control Language）数据控制语言 对数据进行权限控制</h4><p>todo</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>约束是作用与列上的规则，用于限制加入表的数据</li><li>约束的存在保证了数据库中数据的正确性，有效性和完整性</li></ul><h4 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h4><ul><li>非空约束（NOT NULL）</li><li>唯一约束（UNIQUE）</li><li>主键约束（PRIMARY KEY）</li><li>检查约束（CHECK）// mysql不支持该项</li><li>默认约束（DEFAULT）</li></ul><pre><code>create table user (  id INT PRIMARY KEY auto_increment, // 主键  ename VARCHAR(10) NOT NULL UNIQUE, // 非空 唯一  joindata DATA NOT NULL,  salary DOUBLE(7,2) NOT NULL,  bonus DOUBLE(7,2) DEFAULT 0 // 默认);</code></pre><ul><li>外键约束（FOREIGN KEY）</li></ul><pre><code>// 部门表create table dep(  id INT PRIMARY KEY auto_increment,  name varchar(20));// 员工表create table emp(  id INT PRIMARY KEY auto_increment,  name varchar(20),  dep_id int,  constraint fk_emp_dep foreign key(dep_id) references dep(id) // 创建外键);将员工表的dep_id和部门表的id相关联以后插入新员工的时候，dep_id必须是部门表已有的id删除部门表的数据时，该部门表的id没有在员工表的dep_id中出现过</code></pre><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><pre><code>// 部门表create table dep(  id INT PRIMARY KEY auto_increment,  name varchar(20));// 员工表create table emp(  id INT PRIMARY KEY auto_increment,  name varchar(20),  dep_id int,  constraint fk_dep_id foreign key(dep_id) references dep(id) // 创建外键);</code></pre><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><pre><code>// 商品表create table tb_goods(  id INT PRIMARY KEY auto_increment,);// 订单表create table tb_order(  id INT PRIMARY KEY auto_increment,);// 商品和订单的中间表create table tb_goods_order(  goods_id INT,  order_id INT,  count INT,  constraint fk_goods_id foreign key(goods_id) references tb_goods(id),  constraint fk_order_id foreign key(order_id) references tb_order(id));</code></pre><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><pre><code>// 用户表create table tb_user(  id INT PRIMARY KEY auto_increment,  name varchar(10),  detail_id INT UNIQUE,  constraint fk_detail_id foreign key(detail_id) references tb_user_detail(id));// 用户详情表create table tb_user_detail(  id INT PRIMARY KEY auto_increment,  address varchar(20))  </code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><h5 id="内连接查询（查询的是A和B相交的部分）"><a href="#内连接查询（查询的是A和B相交的部分）" class="headerlink" title="内连接查询（查询的是A和B相交的部分）"></a>内连接查询（查询的是A和B相交的部分）</h5><h6 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h6><pre><code>SELECT 字段列表 FROM 表1,表2... where 条件</code></pre><h6 id="显式内连接"><a href="#显式内连接" class="headerlink" title="显式内连接"></a>显式内连接</h6><pre><code>SELECT 字段列表 FROM 表1 [INNER] join 表2 on 条件</code></pre><h5 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h5><h6 id="左外连接查询（查询的是A所有和B相交的部分）"><a href="#左外连接查询（查询的是A所有和B相交的部分）" class="headerlink" title="左外连接查询（查询的是A所有和B相交的部分）"></a>左外连接查询（查询的是A所有和B相交的部分）</h6><pre><code>SELECT 字段列表 FROM 表1 LEFT [OUTER] join 表2 on 条件</code></pre><h6 id="右外连接查询（查询的是B所有和A相交的部分）"><a href="#右外连接查询（查询的是B所有和A相交的部分）" class="headerlink" title="右外连接查询（查询的是B所有和A相交的部分）"></a>右外连接查询（查询的是B所有和A相交的部分）</h6><pre><code>SELECT 字段列表 FROM 表1 RIGHT [OUTER] join 表2 on 条件</code></pre><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>查询中嵌套查询</p><h5 id="子查根据查询结果的不同，作用不同"><a href="#子查根据查询结果的不同，作用不同" class="headerlink" title="子查根据查询结果的不同，作用不同"></a>子查根据查询结果的不同，作用不同</h5><ul><li>单行单列：作为条件值，使用 = != &gt; &lt; 等进行条件判断<pre><code>SELECT 字段列表 FROM 表 WHERE 字段名 = (子查询)</code></pre></li><li>多行单列：作为条件值，使用 in 等关键词进行条件判断<pre><code>SELECT 字段列表 FROM 表 WHERE 字段名 in (子查询)</code></pre></li><li>多行多列：作为虚拟表<pre><code>SELECT 字段列表 FROM (子查询) WHERE 条件</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> java-web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript自带的工具泛型</title>
      <link href="/2022/11/20/TypeScript%E8%87%AA%E5%B8%A6%E7%9A%84%E5%B7%A5%E5%85%B7%E6%B3%9B%E5%9E%8B/"/>
      <url>/2022/11/20/TypeScript%E8%87%AA%E5%B8%A6%E7%9A%84%E5%B7%A5%E5%85%B7%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面总结了<code>ts</code>的高级类型，下面再来说说<code>ts</code>给我们提供的一些基于这些高级类型而成的工具泛型。</p><h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h2><pre><code>/** * Make all properties in T optional * 将T中的所有属性设置为可选 */type Partial&lt;T&gt; = &#123;    [P in keyof T]?: T[P];&#125;;</code></pre><p>官方提供的这个方法，就是将<code>T</code>中的所有属性设置为可选类型。可以看到它使用了<code>in</code>和<code>keyof T</code>来遍历<code>T</code>中的所有<code>key</code>（此时<code>P</code>就代表<code>key</code>），可以看到它使用了<code>?:</code>来将类型改为了可空类型，最后再通过<code>T[P]</code>取值的形式,拿到<code>key</code>对应的属性，最后就生成了一个所有<code>key</code>都和<code>T</code>一样，但都是可空类型的新<code>T</code>类型。下面我们看看效果：</p><img src="/images/5125944-397285fdc655de54.png" width="100%"><br><p>可以看到此处的类型已经发生变化。</p><h2 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h2><pre><code>/** * Make all properties in T required * 使T中的所有属性都是必需的 */type Required&lt;T&gt; = &#123;    [P in keyof T]-?: T[P];&#125;;</code></pre><p><code>Required</code>和<code>Partial</code>是相反的，它的作用是<code>使T中的所有属性都是必需的</code>，<code>[P in keyof T]-?: T[P]</code>里面的<code>-?</code>可以看做是取消掉<code>?</code>的意思，直接贴效果：</p><img src="/images/5125944-7de6dcb0d9577306.png" width="100%"><br><p>可以看到，所有可选类型都变成必选了。</p><h2 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h2><pre><code>/** * Make all properties in T readonly * 将T中的所有属性设置为只读 */type Readonly&lt;T&gt; = &#123;    readonly [P in keyof T]: T[P];&#125;;</code></pre><p>顾名思义，<code>Readonly</code>的作用就是将<code>T</code>中的所有元素设置为只读类型。</p><img src="/images/5125944-29db75e060ecad47.png" width="100%"><br><p>我们可以看的类型<code>age</code>和<code>name</code>已经变成只读类型了。</p><h2 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h2><pre><code>/** * From T, pick a set of properties whose keys are in the union K * 从T中，选择一组键位于联合K中的属性 */type Pick&lt;T, K extends keyof T&gt; = &#123;    [P in K]: T[P];&#125;;</code></pre><p>根据 <code>K extends keyof T</code> 可以得知 <code>K</code> 是单个类型都位于 <code>T</code> 中的联合类型，首先通过 <code>[P in K]</code> 取出联合类型 <code>K</code> 中所有的类型，再将其和 <code>T[P]</code> 的值关联起来，最后返回了一个新的 <code>interface</code> 类型，这个类型里面只包含了联合类型 <code>K</code> 的所有类型。</p><pre><code>interface Person &#123;    name: string,    age: number,    sex: string&#125;type nameAndAge = &quot;name&quot; | &quot;age&quot;const nameAndAgePerson: Pick&lt;Person, nameAndAge&gt; = &#123;    name: &quot;zl&quot;,    age: 27&#125;</code></pre><p>如上示例，因为 <code>K(nameAndAge)</code> 的类型为 <code>name|age</code> ，所以通过 <code>Pick&lt;Person,nameAndAge&gt;</code> 得到的类型是 <code>&#123; name:string , age:number &#125;</code> 。</p><h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><pre><code>/** * Construct a type with a set of properties K of type T * 将联合类型K的所有值作为Key，T作为类型，生成一个新的类型 */type Record&lt;K extends keyof any, T&gt; = &#123;    [P in K]: T;&#125;;</code></pre><p>同样的根据 <code>K extends keyof any</code> 我们可以知道 <code>K</code> 是个联合类型，通过 <code>[P in K]</code> 将联合类型的所有值都取了出来，再将其和 <code>T</code> 关联起来，最后返回了一个新的 <code>interface</code> 类型，这个类型里面的所有属性的类型都是 <code>T</code> 类型。</p><pre><code>interface Person &#123;    name: string,    age: number,    sex: string&#125;type TeacherAndWorker = &quot;teacher&quot; | &quot;worker&quot;const person: Record&lt;TeacherAndWorker, Person&gt; = &#123;    teacher: &#123; name: &#39;zl&#39;, age: 27, sex: &quot;M&quot; &#125;,    worker: &#123; name: &#39;zl&#39;, age: 27, sex: &quot;M&quot; &#125;&#125;</code></pre><p>如上示例可以看出，<code>Record</code> 的作用就是将 <code>K(TeacherAndWorker)</code> 的所有子类型作为 <code>新interface</code> 子属性的 <code>key</code> ，将 <code>T(Person)</code> 作为 <code>新interface</code> 所有子属性的值。</p><h2 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h2><pre><code>/** * Exclude from T those types that are assignable to U * 从T中排除可分配给U的类型 */type Exclude&lt;T, U&gt; = T extends U ? never : T;</code></pre><p><code>Exclude</code> 最常用的还是结合两个联合类型来使用的，我们能通过 <code>Exclude</code> 取出 <code>T</code> 联合类型在 <code>U</code> 联合类型中没有的子类型。</p><pre><code>interface Person &#123;    name: string,    age: number,    sex: string&#125;interface Alien &#123;    name: string,    age: number&#125;const personKeysExcludeAlienKeys: Exclude&lt;keyof Person, keyof Alien&gt; = &quot;sex&quot;</code></pre><p>如上所示，<code>T(keyof Person = name|age|sex)</code> 联合类型在 <code>U(keyof Alien = name|age)</code> 联合类型中没有的子类型只有 <code>sex</code>，所以通过 <code>Exclude&lt;keyof Person, keyof Alien&gt;</code> 返回的类型就是 <code>sex</code>。下面我们再来看看 <code>interface</code> 之间的 <code>Exclude</code>。</p><pre><code>const alien: Exclude&lt;Alien, Person&gt; = &#123;    name: &quot;zl&quot;,    age: 27&#125;    </code></pre><p>可以看到，通过 <code>Exclude&lt;Alien, Person&gt;</code> 我们得到的类型就是 <code>Alien</code> 类型，因为 <code>T(Alien) extends U(Person)</code> 为 <code>false</code> ，所以返回 <code>T(Alien)</code>。这种方式我是想不到什么使用场景。</p><h2 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h2><pre><code>/** * Extract from T those types that are assignable to U * 从T中提取可分配给U的类型 */type Extract&lt;T, U&gt; = T extends U ? T : never;</code></pre><p><code>Extract</code> 和 <code>Exclude</code> 是相反的，最常用的还是结合两个联合类型来使用的，我们能通过 <code>Extract</code> 取出 <code>T</code> 联合类型在 <code>U</code> 联合类型中所有重复的子类型。</p><img src="/images/5125944-fc2ef49fbd1c8bfe.png" width="100%"><br><p>如图所示，此时通过 <code>Extract&lt;keyof Person, keyof Alien&gt;</code> 返回的是联合类型 <code>name|age</code>。</p><h2 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h2><pre><code>/** * Construct a type with the properties of T except for those in type K. * 构造一个属性为T的类型，但类型K中的属性除外。 */type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code></pre><p><code>Omit</code> 就是 <code>Pick</code> 和 <code>Exclude</code> 的组合，首先我们可以通过 <code>K extends keyof any</code> 得知 <code>K</code> 为联合类型，然后通过 <code>Exclude&lt;keyof T, K&gt;</code> 我们取出了在联合类型 <code>keyof T</code> 中有，而在 <code>K</code> 中没有的子属性(这里我们假设是 <code>联合类型M</code> )，最后再通过 <code>Pick&lt;T,M&gt;</code> 得到一个新的 <code>interface</code> 类型，这个类型里面只包含了联合类型 <code>M</code> 的所有类型。<em><strong>简单的讲 <code>Omit</code> 就是从类型 <code>T</code> 中取出在 <code>联合类型K</code> 中所没有的类型。</strong></em></p><pre><code>interface Person &#123;    name: string,    age: number,    sex: string&#125;const person: Omit&lt;Person, &quot;name&quot; | &quot;age&quot;&gt; = &#123; sex: &quot;M&quot; &#125;;</code></pre><p>如上示例，我们取出了在 <code>T(Person)</code> 里面除去 <code>K(&quot;name&quot;|&quot;age&quot;)</code> 以外的类型 <code>sex</code> ，并组成了一个新的 <code>interface</code>。</p><h2 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h2><pre><code>/** * Exclude null and undefined from T *  从T中剔除null和undefined */type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</code></pre><p>就是字面意思，去除掉联合类型中的 <code>null</code> 和 <code>undefined</code> 类型。如下图所示，</p><img src="/images/5125944-be1bc2dc54865aaa.png" width="100%"><br><p>使用 <code>NonNullable</code> 之后去掉了联合类型 <code>null | undefined | number | string</code> 中的 <code>null</code> 和 <code>undefined</code> 类型，剩下了 <code>number|string</code>。</p><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><pre><code> /** * Obtain the parameters of a function type in a tuple * 获取元组中函数类型的参数 */type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;</code></pre><p>根据 <code>&lt;T extends (...args: any) =&gt; any&gt;</code> 我们能够知道 <code>T</code> 是个函数类型，再通过 <code>T extends (...args: infer P) =&gt; any</code> 将 <code>T</code> 的形参列表约束成了泛型 <code>P</code> ，所以通过三元运算返回的是函数类型 <code>T</code> 的形参元组。</p><pre><code>function fn(str: string, num: number) &#123;&#125;type fnParamtersTuple = Parameters&lt;typeof fn&gt;</code></pre><img src="/images/5125944-4d0cac21ce6fafd5.png" width="100%"><br><p>如图所示，<code>fnParamtersTuple</code> 的类型为，<code>fn</code> 的形参类型的元组。</p><h2 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters</h2><pre><code>/** * Obtain the parameters of a constructor function type in a tuple * 获取元组中构造函数类型的参数 */type ConstructorParameters&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: infer P) =&gt; any ? P : never;</code></pre><p>和 <code>Parameters</code> 类似，只不过 <code>ConstructorParameters</code> 获取的是构造函数的形参元组。下面以官网上介绍 <code>interface类静态部分与实例部分的区别</code> 中的例子改变一下作为demo。</p><pre><code>interface ClockConstructor &#123;    new(hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123;    tick();&#125;//通过 ConstructorParameters&lt;ClockConstructor&gt; 获取构造函数中的形参元组function createClock(ctor: ClockConstructor, ...arg: ConstructorParameters&lt;ClockConstructor&gt;): ClockInterface &#123;    return new ctor(...arg);&#125;class DigitalClock implements ClockInterface &#123;    constructor(h: number, m: number) &#123; &#125;    tick() &#123;        console.log(&quot;beep beep&quot;);    &#125;&#125;let digital = createClock(DigitalClock, 12, 17);</code></pre><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><pre><code>/** * Obtain the return type of a function type * 获取函数类型的返回类型 */type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</code></pre><p>和 <code>Parameters</code> 类似，只不过 <code>ReturnType</code> 获取的是函数类型的返回类型。</p><pre><code> function fn() : string &#123;     return &quot;&quot; &#125; type fnReturnType = ReturnType&lt;typeof fn&gt;</code></pre><img src="/images/5125944-83e80e5357848ba4.png" width="100%"><br><h2 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h2><pre><code>/** * Obtain the return type of a constructor function type */type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any;</code></pre><p>和 <code>Parameters</code> 类似，只不过 <code>ConstructorParameters</code> 获取的是构造函数返回值的类型。</p><pre><code>class Person &#123; &#125;class Alien &#123; &#125;type p0 = InstanceType&lt;typeof Person&gt; // Personinterface PersonConstructor &#123;    new(): Person&#125;type p1 = InstanceType&lt;PersonConstructor&gt; // Personinterface PersonAndAlienConstructor &#123;    new(): Person | Alien&#125;type p2 = InstanceType&lt;PersonAndAlienConstructor&gt; // Person | Alien</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Advanced Type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 高级类型</title>
      <link href="/2022/11/20/TypeScript-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/11/20/TypeScript-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>之前一直使用的是 <strong>js</strong> 现在转过来学习 <strong>ts</strong> 的时候尝到了 <strong>ts</strong> 对类型规范的很多好处，相应的 <strong>ts</strong> 的类型有时候也让人头大,下面简单总结一下自己对 <strong>ts</strong> 高级类型的学习成果。</p><h1 id="一般类型"><a href="#一般类型" class="headerlink" title="一般类型"></a>一般类型</h1><hr><pre><code>//给变量指定类型const value: string = &quot;value&quot;//给方法的形参和返回值指定类型const fun0 = (str: string): string =&gt; &#123;    return &quot;&quot;&#125;//甚至可以直接给方法指定类型type funType = (str: string) =&gt; stringconst fun1: funType = (str) =&gt; &#123;    return &quot;&quot;&#125;</code></pre><p>这个时候我们可以看的 <code>fun1</code> 这时候是不用指定 <code>str</code> 的类型的，IDE会自动提示，如下：</p><img src="/images/5125944-2a5d0f6c35cf0f85.png" width="100%"><br><p>但还有个特殊的情况 <code>fun1</code> 的形参是可以不写的，比如：</p><pre><code>type funType = (str: string) =&gt; stringconst fun2: funType = () =&gt; &#123;    return &quot;fun2 return value&quot;&#125;console.log(fun2(&quot;value&quot;));</code></pre><p>这样是不会报错的，可是为什么呢？我们明明指定了<code>funType</code>的形参有且是<code>string</code>，那大家肯定想问真是为什么，抱歉我也不知道，哈哈哈！如果有知道的朋友希望能留言告知。这样做的问题是在<code>fun2</code>里面是拿不到传入的形参的，不知道是不是bug。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><hr><p>对就是它，我个人来说在学习和使用<code>ts</code>的途中最头疼的就是泛型，<code>ts</code>中泛型的使用真的让人头晕眼花，但当你真的看明白<code>ts</code>中泛型的使用是又不得不说这简直就像是在变魔术。下面记录一下泛型的一般用法：</p><pre><code>//将对象中值为number类型的数据组成一个新对象function getObjAllNum&lt;T&gt;(t: T): any &#123;    let numObj = &#123;&#125; as any;    for (const tKey in t) &#123;        if (typeof t[tKey] == &quot;number&quot;) &#123;            numObj[tKey] = t[tKey]        &#125;    &#125;    return numObj&#125;const value = &#123;    name: &#39;zl&#39;,    age: 27,    sex: &#39;m&#39;&#125;//输出 &#123;age: 27&#125;console.log(getObjAllNum(value));</code></pre><p>可以看到，当我们调用<code>getObjAllNum</code>的时候<code>T</code>类型已经转变成对象<code>value</code>的类型了。</p><img src="/images/5125944-9c713ea3c4d78cfd.png" width="100%"><br><h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><hr><p>接下来要说的就是<code>ts</code>为我们提供的一些类型的高级操作方式</p><h2 id="类型别名（type）"><a href="#类型别名（type）" class="headerlink" title="类型别名（type）"></a>类型别名（type）</h2><p>可以理解成可以给一个类型再取另一个名字，比如：</p><pre><code>type myString = stringconst str: myString = &quot;str&quot;</code></pre><h2 id="联合类型（-）"><a href="#联合类型（-）" class="headerlink" title="联合类型（|）"></a>联合类型（|）</h2><p><code>A|B</code>表示<code>A</code>或者<code>B</code>中的任意一个类型 ，如下代码，<code>zhangSan</code>就是属于<code>Man</code>类型，<code>xiaoLi</code>属于<code>Woman</code>类型。</p><pre><code>interface Man &#123;    working(): void;&#125;interface Woman &#123;    shopping(): void;&#125;type Person = Man | Womanconst zhangSan: Person = &#123;    working() &#123;        console.log(&#39;working&#39;)    &#125;&#125;zhangSan.working()const xiaoLi: Person = &#123;    shopping() &#123;        console.log(&#39;shopping&#39;)    &#125;&#125;xiaoLi.shopping()</code></pre><p>但需要注意的是下面这种写法：</p><pre><code>const person: Person = &#123;    working() &#123;        console.log(&#39;working&#39;)    &#125;,    shopping() &#123;        console.log(&#39;shopping&#39;)    &#125;&#125;</code></pre><p>这样写是不会报错的，但是当试图调用方法的时候就会报错，可以看出调用<code>shopping</code>的时候，就会提示<code>Man</code>不存在<code>shopping</code>属性，其实这是因为<code>A|B</code>联合类型表示的是<code>A</code>或者<code>B</code>中的任意一个类型，只有一个类型，而不是两种类型的合并，下面来说说真正的合并<code>交叉类型（&amp;）</code></p><img src="/images/5125944-7709f5ba1f5db227.png" width="100%"><br><h2 id="交叉类型（-amp-）"><a href="#交叉类型（-amp-）" class="headerlink" title="交叉类型（&amp;）"></a>交叉类型（&amp;）</h2><p><code>A&amp;B</code>高级类型是将两个类型合并成了一个类型，这个类型拥有<code>A</code>和<code>B</code>的所有属性，所以称其为<code>合并类型</code>也没啥毛病。<strong>这东西才学的时候一直以为是交集，其实应该是并集才对。</strong></p><pre><code>interface Apple &#123;    size: string,    color: string,&#125;interface Pen &#123;    type: string,    color: string,&#125;type Pineapple = Apple &amp; Penconst pineapple: Pineapple = &#123;    size: &#39;大&#39;,    color: &#39;黄色&#39;,    type: &#39;海南凤梨&#39;&#125;</code></pre><p>这里有个问题就是两个<code>Interface</code>做交叉类型时，如果含有相同的<code>key</code>会出现什么问题呢？<a href="https://www.jianshu.com/p/38bc2dac26b5">详情请见另一篇</a>。</p><h2 id="类型索引（keyof）"><a href="#类型索引（keyof）" class="headerlink" title="类型索引（keyof）"></a>类型索引（keyof）</h2><p><code>keyof</code>的作用是将一个类型拆分开了，将拆分出来的子类型的集合作为类型返回，如下代码，<code>PersonKeys</code>的类型（图<code>keyof.png</code>所示）为<code>name|age</code>这种联合类型</p><pre><code>interface Person &#123;    name: string,    age: number&#125;type PersonKeys = keyof Person</code></pre><img src="/images/5125944-20ef51582f5f8d3a.png" width="100%"><br><h2 id="类型约束（extends）"><a href="#类型约束（extends）" class="headerlink" title="类型约束（extends）"></a>类型约束（extends）</h2><p><code>extends</code>的作用是约束泛型，将泛型的类型限定成某个类型，如下例子:<code>logPersonInfo&lt;Person&gt;()</code>可以传入<code>Man</code>和<code>Woman</code>两种类型，但<code>logPersonInfo&lt;Man&gt;()</code>却只能传入<code>Man</code>类型,<code>logPersonInfo&lt;Woman&gt;()</code>却只能传入<code>Woman</code>类型。</p><pre><code>interface Person &#123;    name: string,    age: number&#125;class Man implements Person &#123;    name = &#39;zhangSan&#39;;    age = 27;    working() &#123;&#125;&#125;class Woman implements Person &#123;    name = &#39;xiaoLi&#39;;    age = 26;    shopping() &#123;&#125;&#125;function logPersonInfo&lt;T extends Person&gt;(t: T) &#123;    console.log(`name : $&#123;t.name&#125; , age : $&#123;t.age&#125;`)&#125;logPersonInfo&lt;Person&gt;(new Man())logPersonInfo&lt;Person&gt;(new Woman())logPersonInfo&lt;Man&gt;(new Man())logPersonInfo&lt;Woman&gt;(new Woman())</code></pre><p>下面再说一种情况，来更加深入的了解<code>extends</code>:</p><pre><code>interface Person &#123;    name: string,    age: number&#125;class Alien &#123;    name = &quot;E.T&quot;    age = 1000    fly() &#123;    &#125;&#125;function logPersonInfo&lt;T extends Person&gt;(t: T) &#123;    console.log(`name : $&#123;t.name&#125; , age : $&#123;t.age&#125;`)&#125;logPersonInfo&lt;Person&gt;(new Alien())</code></pre><p>这个时候我们传入<code>logPersonInfo&lt;Person&gt;()</code>的是一个<code>Alien</code>，这时候也不会有什么问题，因为<code>Alien</code>包含了<code>Person</code>的所有属性。对比两个例子我们能看得出来这里的<code>extends</code>和类继承的<code>extends</code>是不一样的，这个地方的<code>extends</code>起到的作用只是限制泛型<code>T</code>的类型为包含了<code>Person</code>类型的所有属性（<strong>当然所有属性的类型也要一致</strong>）的类型。</p><h2 id="类型映射（in）"><a href="#类型映射（in）" class="headerlink" title="类型映射（in）"></a>类型映射（in）</h2><p><code>in</code>高级类型起到的作用是做类型的映射，它会遍历<strong>已有类型的所有key</strong>或者是<strong>联合类型的所有类型</strong>，有点类似于<code>forin</code>。下面我们写的demo，将已有类型的所有属性转换成可空类型。</p><pre><code>interface Person &#123;    name: string;    age: number;&#125;//此时这里的P就是in遍历出来的key//将Person的所有key遍历出来设置成?:可空类型，再赋值上key对应的value//这时候的PersonValueCanNull类型就是所有属性可为空的Person类型了type PersonValueCanNull = &#123; [P in keyof Person]?: Person[P] &#125;</code></pre><p>如上代码，这个时候<code>PersonValueCanNull</code>的类型为<code>&#123;name?: string, age?: number&#125;</code>,如图：</p><img src="/images/5125944-5d14c681a6266115.png" width="100%"><br><p>再来个联合类型的例子：</p><pre><code>type ValueKeyType = &quot;key1&quot; | &quot;key2&quot; | &quot;key3&quot;type ValueType = &#123; [P in ValueKeyType]: boolean &#125;const value: ValueType = &#123;    key1: false,    key2: false,    key3: false,&#125;</code></pre><p>结合上面联合类型的例子，我们再来看第一个例子，<code>[P in keyof Person]</code>就可以拆分成<code>[P in keyof &quot;name&quot;|&quot;age&quot;]</code>，其实最终都是使用联合类型来进行<code>in</code>操作</p><h2 id="条件类型（A-B-C）"><a href="#条件类型（A-B-C）" class="headerlink" title="条件类型（A ? B : C）"></a>条件类型（A ? B : C）</h2><p><code>条件类型</code>其实就是一个三元运算操作，如果满足条件<code>A</code>那么就是<code>B</code>类型，否则就是<code>C</code>类型，话不多说上代码：</p><pre><code>//传入T和U，如果T包含U所有的key，那么返回类型是T，反之返回的是T和U的交叉类型type MergeAction&lt;T, U&gt; = T extends U ? T : T &amp; Uinterface Teacher &#123;    name: string,    age: number,    teachStudentNum: number&#125;interface Father &#123;    name: string,    age: number,    childNum: number&#125;//回顾一下之前的 extends， Teacher里面没有包含Father里面的//所有key，所以返回的是Teacher&amp;Father的交叉类型const person: MergeAction&lt;Teacher, Father&gt; = &#123;    name: &#39;zl&#39;,    age: 27,    teachStudentNum: 60,    childNum: 1&#125;</code></pre><p>类型如图：</p><img src="/images/5125944-b19d136fdd1c9c65.png" width="100%"><br><p>下面我们再来个<code>keyof</code>的例子</p><pre><code>const person :MergeAction&lt;keyof Teacher, keyof Father&gt; = &quot;name&quot;</code></pre><p>此时的类型就是 <code>name|age</code>的<code>联合类型</code>了。<br><img src="/images/5125944-742a495f249e6f45.png" width="100%"><br><br></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Advanced Type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 蓝牙搜索，配对，连接发送数据</title>
      <link href="/2022/11/20/Android-%E8%93%9D%E7%89%99%E6%90%9C%E7%B4%A2%EF%BC%8C%E9%85%8D%E5%AF%B9%EF%BC%8C%E8%BF%9E%E6%8E%A5%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/11/20/Android-%E8%93%9D%E7%89%99%E6%90%9C%E7%B4%A2%EF%BC%8C%E9%85%8D%E5%AF%B9%EF%BC%8C%E8%BF%9E%E6%8E%A5%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>首先需要在清单配置里面添加两个权限:</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;</code></pre><p>android里面蓝牙是通过BluetoothAdapter来进行操作的，所以首先我们需要获取到BluetoothAdapter的实例</p><pre><code>//先获取BlueToothAdapter的实例BluetoothAdapter blueToothAdapter = BluetoothAdapter.getDefaultAdapter();</code></pre><p>在搜索之前，我们可以先获取与我们配对过的设备</p><pre><code>//获取已经配对过的设备的集合Set&lt;BluetoothDevice&gt; bondedDevices = blueToothAdapter.getBondedDevices()</code></pre><p>但是想要获取到配对过的设备，我们必须是在</p><pre><code>//手机有蓝牙设备并且蓝牙是打开的blueToothAdapter != null &amp;&amp; blueToothAdapter.isEnabled()</code></pre><p>下面我们谈一下蓝牙的<b>打开方式</b>，目前作者知道的方式有3种<br>第一种：</p><pre><code>//强制打开蓝牙blueToothAdapter.enable();</code></pre><p>第二种：</p><pre><code>//会以dialog的形式打开一个activity，并且如果我们通过startActivityForResult的形式的话//还能查看蓝牙是否被打开，或者处理蓝牙被打开之后的操作//如果是result_ok的话那么是打开，反之打开失败startActivityForResult(new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE));</code></pre><p>第三种：</p><pre><code>//设置本地设备可以被其它设备搜索，可被搜索的时间是有限的，最多为300s//效果和第二种类似Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);startActivity(discoverableIntent);</code></pre><p><b>关闭蓝牙</b>我们可以调用</p><pre><code>blueToothAdapter.disable();</code></pre><p>接下来是<b>蓝牙搜索</b><br>首先如果想要开启蓝牙搜索，那么只需要调用</p><pre><code>blueToothAdapter.startDiscovery();</code></pre><p>但是我们该如何接收我们搜索到的设备呢，很明显当然是通过接收广播的形式来接收。所以我们应该自定义一个广播接收器，</p><pre><code>class BluetoothReceiver extends BroadcastReceiver &#123;        @Override        public void onReceive(Context context, Intent intent) &#123;            if (intent.getAction().equals(BluetoothDevice.ACTION_FOUND)) &#123;                Log.e(getPackageName(), &quot;找到新设备了&quot;);                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);            &#125;        &#125;    &#125;</code></pre><p>如上代码，我们可以获取到搜索到的蓝牙设备。我们只需在代码里面注册这个广播接收器，在调用蓝牙的搜索方法，就能够进行蓝牙的搜索了。</p><pre><code>//注册广播IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(BluetoothDevice.ACTION_FOUND);registerReceiver(new BluetoothReceiver(), intentFilter);</code></pre><p>这里需要注意的是，如果你的代码将运行在（Build.VERSION.SDK_INT &gt;= 23）的设备上，那么务必加上以下权限，并在代码中动态的申请权限</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;</code></pre><pre><code>private void requestPermission() &#123;        if (Build.VERSION.SDK_INT &gt;= 23) &#123;            int checkAccessFinePermission = ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION);            if (checkAccessFinePermission != PackageManager.PERMISSION_GRANTED) &#123;                ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.ACCESS_FINE_LOCATION&#125;,                        REQUEST_PERMISSION_ACCESS_LOCATION);                Log.e(getPackageName(), &quot;没有权限，请求权限&quot;);                return;            &#125;            Log.e(getPackageName(), &quot;已有定位权限&quot;);            //这里可以开始搜索操作        &#125;    &#125;    @Override    public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123;        switch (requestCode) &#123;            case REQUEST_PERMISSION_ACCESS_LOCATION: &#123;                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;                    Log.e(getPackageName(), &quot;开启权限permission granted!&quot;);                    //这里可以开始搜索操作                &#125; else &#123;                    Log.e(getPackageName(), &quot;没有定位权限，请先开启!&quot;);                &#125;            &#125;        &#125;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);    &#125;</code></pre><p>再来就是<b>蓝牙的配对</b>，目前楼主采用的是通过反射的形式来调用BluetoothDevice的createBondde()方法，如果我们想监听配对的这个过程，那么我们可以为广播接收器再注册一个action。</p><pre><code>try &#123;      //如果想要取消已经配对的设备，只需要将creatBond改为removeBond       Method method = BluetoothDevice.class.getMethod(&quot;createBond&quot;);       Log.e(getPackageName(), &quot;开始配对&quot;);       method.invoke(device);    &#125; catch (Exception e) &#123;      e.printStackTrace();    &#125;</code></pre><pre><code>//绑定状态发生变化intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);</code></pre><p>广播接收器里面我们可以这样写</p><pre><code>if (intent.getAction().equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) &#123;                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);                switch (device.getBondState()) &#123;                    case BluetoothDevice.BOND_NONE:                        Log.e(getPackageName(), &quot;取消配对&quot;);                        break;                    case BluetoothDevice.BOND_BONDING:                        Log.e(getPackageName(), &quot;配对中&quot;);                        break;                    case BluetoothDevice.BOND_BONDED:                        Log.e(getPackageName(), &quot;配对成功&quot;);                        break;                &#125;&#125;</code></pre><p>再来就是<b>向已经配对的设备发送数据</b><br>发送数据分为服务端和客户端，通过socket来进行消息的交互。</p><p>服务端</p><pre><code>new Thread(new Runnable() &#123;            @Override            public void run() &#123;                InputStream is = null;                try &#123;                    BluetoothServerSocket serverSocket = blueToothAdapter.listenUsingRfcommWithServiceRecord(&quot;serverSocket&quot;, uuid);                    mHandler.sendEmptyMessage(startService);                    BluetoothSocket accept = serverSocket.accept();                    is = accept.getInputStream();                    byte[] bytes = new byte[1024];                    int length = is.read(bytes);                    Message msg = new Message();                    msg.what = getMessageOk;                    msg.obj = new String(bytes, 0, length);                    mHandler.sendMessage(msg);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;).start();</code></pre><p>客户端</p><pre><code>new Thread(new Runnable() &#123;            @Override            public void run() &#123;                OutputStream os = null;                try &#123;                    BluetoothSocket socket = strArr.get(i).createRfcommSocketToServiceRecord(uuid);                    socket.connect();                    os = socket.getOutputStream();                    os.write(&quot;testMessage&quot;.getBytes());                    os.flush();                    mHandler.sendEmptyMessage(sendOver);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;).start();</code></pre><p>可以看到无论是服务端还是客户端，都需要新起一个子线程来操作。那么服务端和客户端是怎么识别对方的呢，那么就需要用到<b>UUID</b>了，只有当服务端和客户端的<b>UUID</b>相同的时候才能够建立连接。</p><p><b>蓝牙连接发送数据的时候的坑</b><br>当博主第一次写好客户端服务端测试的时候，服务端一直报错</p><pre><code>java.io.IOException: bt socket closed, read return: -1</code></pre><p>也就是这句话报错</p><pre><code>is.read(bytes)</code></pre><p>当时一直以为是读取返回值是-1就会报错，但是不对啊，以前这么写也没错过，在网上百度了半天，看了别人的博客论坛也没有解决办法，最后才注意到报错的前一句，</p><pre><code>bt socket closed</code></pre><p>之前一直认为是什么服务端这边，报错连接才会断开，后来一想客户端也会断开连接啊，这才找到问题所在。原来是我当时write完数据之后将连接关闭了，这才导致服务端这边连接断开的。所以重要的事情要说3遍，千万别急着断开连接，千万别急着断开连接，千万别急着断开连接。</p><p><a href="https://github.com/MonkZl/BlueToothDemo">github源代码链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>item高度动态变化的RecyclerView</title>
      <link href="/2022/11/20/item%E9%AB%98%E5%BA%A6%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96%E7%9A%84RecyclerView/"/>
      <url>/2022/11/20/item%E9%AB%98%E5%BA%A6%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96%E7%9A%84RecyclerView/</url>
      
        <content type="html"><![CDATA[<h2 id="首先来看一下效果图"><a href="#首先来看一下效果图" class="headerlink" title="首先来看一下效果图"></a>首先来看一下效果图</h2><div style="text-align: center; display: flex; justify-content: space-around;">    <div>        <img src="/images/5125944-77e025a2d814f062.gif" width="256" height="256">        <div>linearLayoutManager</div>    </div>    <div>        <img src="/images/5125944-a03770304bb1a3f1.gif" width="256" height="256">        <div>gridLayoutManager</div>    </div></div><br><p>首先可以确定的是每个item肯定是有最大高度和最小高度的，所以我们先要给定item的目标高度（targetHeight）和初始高度（defaultHeight）。<br></br><br>就以LinearLayoutManager和targetHeight大于defaultHeight为例，都是第一排的item往上滑动的时候item高度是减小的，但是第二排的item的高度是增加的，很明显的能看出当我们滑动的时候，列表滑动是很流畅的，不难看出第一排item高度的减小和第二排item高度的增加是守恒的，也就是说这两个高度相加是一直等于targetHeight+defaultHeight的，所有我们只需要确定了第一个item的高度那么第二个item的高度就等于targetHeight+defaultHeight-第一个item的高度。<br></br><br>那么第一个item的高度要怎么确定呢，理论上这个top绝对值的的最大值是defaultheight,因为当第一个item快要完全划出去的时候我们通过getTop获取到的高度就应该是defaultHeight，而且第一个item就应该根据top的变化来动态的改变自己的高度，而top绝对值变化的范围就是在targetHeight和defaultHeight之间的，那么根据高度的变化就等于(top * 1f / defaultHeight) * (targetHeight - defaultHeight)，再通过和targetHeight求和就得到了第一个item的高度了，可以看出第一个item高度的范围，当top为0的时候是targetHeight，当top为-targetHeight的时候（不难看出第一个item的top值一直是小于等于0的）是defaultHeight。</p><pre><code>View childAt0 = getChildAt(0);ViewGroup.LayoutParams layoutParams0 = childAt0.getLayoutParams();int top = childAt0.getTop();top = top &lt;= -defaultHeight ? -defaultHeight : top;layoutParams0.height = (int) (targetHeight + (top * 1f / defaultHeight) * (targetHeight - defaultHeight));childAt0.requestLayout();</code></pre><p>那么第二个item的高度确定的方法上面也说了，就是等于总高度减去第一个item的高度。</p><pre><code>View childAt1 = getChildAt(1);ViewGroup.LayoutParams layoutParams1 = childAt1.getLayoutParams();layoutParams1.height = defaultHeight + targetHeight - getChildAt(0).getLayoutParams().height;childAt1.requestLayout();</code></pre><p>接下来的item高度就好确定了，都是defaultHeight。</p><pre><code>View childAt = getChildAt(i);ViewGroup.LayoutParams layoutParams = childAt.getLayoutParams();layoutParams.height = defaultHeight;childAt.requestLayout();</code></pre><h2 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h2><p>如果用户滑动速度比较慢，那么top的绝对值一直是小于等于defaultHeight的，但是当用户快速滑动的时候top的绝对值就会出现比defaultHeight大的情况，这个bug目前还不知道是怎么产生的（如果有大佬知道，希望大佬给点意见）,所以目前先在第一个item确定高度的地方加上了</p><pre><code>top = top &lt;= -defaultHeight ? -defaultHeight : top;</code></pre><p>这个判断避免出现top绝对值大于defaultHeight 的情况。</p><p><a href="https://github.com/MonkZl/FreeStyleRecyclerViewDemo">github源代码链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>intentFilter的匹配规则</title>
      <link href="/2022/11/20/intentFilter%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
      <url>/2022/11/20/intentFilter%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>在说明intentFilter之前首先需要介绍一下Activity的启动方式，分为显示启动和隐式启动。</p><h2 id="显示启动"><a href="#显示启动" class="headerlink" title="显示启动"></a>显示启动</h2><pre><code>//显示启动只需要添加一个context对象和一个类对象就行了Intent intent = new Intent(MainActivity.this, ActivityData.class);startActivity(intent);</code></pre><h2 id="隐式启动"><a href="#隐式启动" class="headerlink" title="隐式启动"></a>隐式启动</h2><p>说到隐式启动就要谈到intentFilter的匹配了,下面这段在配置文件里面的activity的intent-filter,如果我们想要通过隐式启动的方式打开这个activity，那么就需要为intent<b>指定</b>action，<b>添加</b>category，<b>指定</b>data</p><pre><code>&lt;intent-filter&gt;                &lt;action android:name=&quot;action&quot; /&gt;                &lt;action android:name=&quot;action_copy&quot;/&gt;                &lt;category android:name=&quot;category&quot; /&gt;                &lt;category android:name=&quot;category_copy&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;                &lt;data                    android:mimeType=&quot;text/plain&quot;                    android:host=&quot;zl&quot;                    android:path=&quot;/zl/mon&quot;                    android:port=&quot;8080&quot;                    android:scheme=&quot;http&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>下面贴出通过隐式启动的方式打开该activity的方法</p><pre><code>Intent intent = new Intent();intent.setAction(&quot;action&quot;);intent.addCategory(&quot;category&quot;);intent.setDataAndType(Uri.parse(&quot;http://zl:8080/zl/mon&quot;),&quot;text/plain&quot;);startActivity(intent);</code></pre><h2 id="Action的匹配规则"><a href="#Action的匹配规则" class="headerlink" title="Action的匹配规则"></a>Action的匹配规则</h2><p>其实关于action的匹配规则可以在上面通过隐式启动activity的方式中看出，是为intent<b>设置</b>action(<b>intent.setAction(“action”)</b>)，所以<b>只需要设置的action和配置文件中的某一个<action />匹配就行了</b>。</p><h2 id="Category的匹配规则"><a href="#Category的匹配规则" class="headerlink" title="Category的匹配规则"></a>Category的匹配规则</h2><p>同理category的匹配规则，也能通过上述的代码来理解，可以看出为intent设置category的方法是<b>intent.addCategory(“category”)</b>,很明显的能明白是添加category，那么category的匹配方式就是<b>已添加的category必须是清单文件里面有的category</b>。</p><h2 id="Category的坑"><a href="#Category的坑" class="headerlink" title="Category的坑"></a>Category的坑</h2><p>可以看到，在上面category里面有</p><pre><code> &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</code></pre><p>而我们也没有在代码里面设置它，那么我们是不是可以在清单配置文件里面把它删除了呢。大家可以试试，如果删除，再次打开activity的时候就会报错。<br>其实原理很简单，因为<b>这个category系统已经默认的帮我们把它添加到intent里面了</b>，所以当打开activity的时候，系统就去匹配category，发现系统默认帮我们添加的</p><pre><code> &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</code></pre><p>属性并不存在，那么当然就无法匹配成功啦。</p><h2 id="Data的匹配规则"><a href="#Data的匹配规则" class="headerlink" title="Data的匹配规则"></a>Data的匹配规则</h2><pre><code>&lt;data          android:mimeType=&quot;text/plain&quot;          android:host=&quot;zl&quot;          android:path=&quot;/zl/mon&quot;          android:port=&quot;8080&quot;          android:scheme=&quot;http&quot; /&gt;</code></pre><pre><code>intent.setDataAndType(Uri.parse(&quot;http://zl:8080/zl/mon&quot;),&quot;text/plain&quot;);</code></pre><p>简单的说data就相当于一个网址的拼接，并且还指定了一个type，拼接方式大致如下:</p><pre><code>scheme://host:port/[path|pathPattern|pathPrefix]</code></pre><pre><code>http://zl:8080/zl/mon</code></pre><p><b>path</b>：表示的是完整的一个路径，如上面的/zl/mon。<br><b>pathPattern</b>：也表示完整的路径，但是它里面可以包含通配符，如 “.” 代表”a”,”b”等，”*“ 代表复数，比如”a*“，能匹配 “a” ,”aa” 等。<br><b>pathPrefix</b>：表示路径的前缀信息,将pathPrefix设置成/zl就能进行匹配了。</p><p>这里需要注意的是，data没有默认参数，而且port，path，pathPattern，pathPrefix等参数只有在scheme和host设置了的情况下才有效。</p><p>还有需要注意的是下面两段代码是等同的</p><pre><code>&lt;data                    android:host=&quot;zl&quot;                    android:mimeType=&quot;text/plain&quot;                    android:path=&quot;/zl/mon&quot;                    android:port=&quot;8080&quot;                    android:scheme=&quot;http&quot; /&gt;</code></pre><pre><code>&lt;data                    android:host=&quot;zl&quot;                    android:mimeType=&quot;text/plain&quot;                   /&gt;&lt;data                    android:path=&quot;/zl/mon&quot;                    android:port=&quot;8080&quot;                    android:scheme=&quot;http&quot; /&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
