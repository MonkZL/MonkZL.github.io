<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-20T03:50:58.689Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript自带的工具泛型</title>
    <link href="http://example.com/2022/11/20/TypeScript%E8%87%AA%E5%B8%A6%E7%9A%84%E5%B7%A5%E5%85%B7%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2022/11/20/TypeScript%E8%87%AA%E5%B8%A6%E7%9A%84%E5%B7%A5%E5%85%B7%E6%B3%9B%E5%9E%8B/</id>
    <published>2022-11-20T03:42:42.000Z</published>
    <updated>2022-11-20T03:50:58.689Z</updated>
    
    <content type="html"><![CDATA[<p>#前言</p><p>前面总结了<code>ts</code>的高级类型，下面再来说说<code>ts</code>给我们提供的一些基于这些高级类型而成的工具泛型。</p><p>##Partial</p><pre><code>/** * Make all properties in T optional * 将T中的所有属性设置为可选 */type Partial&lt;T&gt; = &#123;    [P in keyof T]?: T[P];&#125;;</code></pre><p>官方提供的这个方法，就是将<code>T</code>中的所有属性设置为可选类型。可以看到它使用了<code>in</code>和<code>keyof T</code>来遍历<code>T</code>中的所有<code>key</code>（此时<code>P</code>就代表<code>key</code>），可以看到它使用了<code>?:</code>来将类型改为了可空类型，最后再通过<code>T[P]</code>取值的形式,拿到<code>key</code>对应的属性，最后就生成了一个所有<code>key</code>都和<code>T</code>一样，但都是可空类型的新<code>T</code>类型。下面我们看看效果：</p><img src="/images/5125944-397285fdc655de54.png" width="100%"><br><p>可以看到此处的类型已经发生变化。</p><p>##Required</p><pre><code>/** * Make all properties in T required * 使T中的所有属性都是必需的 */type Required&lt;T&gt; = &#123;    [P in keyof T]-?: T[P];&#125;;</code></pre><p><code>Required</code>和<code>Partial</code>是相反的，它的作用是<code>使T中的所有属性都是必需的</code>，<code>[P in keyof T]-?: T[P]</code>里面的<code>-?</code>可以看做是取消掉<code>?</code>的意思，直接贴效果：</p><img src="/images/5125944-7de6dcb0d9577306.png" width="100%"><br><p>可以看到，所有可选类型都变成必选了。</p><p>##Readonly</p><pre><code>/** * Make all properties in T readonly * 将T中的所有属性设置为只读 */type Readonly&lt;T&gt; = &#123;    readonly [P in keyof T]: T[P];&#125;;</code></pre><p>顾名思义，<code>Readonly</code>的作用就是将<code>T</code>中的所有元素设置为只读类型。</p><img src="/images/5125944-29db75e060ecad47.png" width="100%"><br><p>我们可以看的类型<code>age</code>和<code>name</code>已经变成只读类型了。</p><p>##Pick</p><pre><code>/** * From T, pick a set of properties whose keys are in the union K * 从T中，选择一组键位于联合K中的属性 */type Pick&lt;T, K extends keyof T&gt; = &#123;    [P in K]: T[P];&#125;;</code></pre><p>根据 <code>K extends keyof T</code> 可以得知 <code>K</code> 是单个类型都位于 <code>T</code> 中的联合类型，首先通过 <code>[P in K]</code> 取出联合类型 <code>K</code> 中所有的类型，再将其和 <code>T[P]</code> 的值关联起来，最后返回了一个新的 <code>interface</code> 类型，这个类型里面只包含了联合类型 <code>K</code> 的所有类型。</p><pre><code>interface Person &#123;    name: string,    age: number,    sex: string&#125;type nameAndAge = &quot;name&quot; | &quot;age&quot;const nameAndAgePerson: Pick&lt;Person, nameAndAge&gt; = &#123;    name: &quot;zl&quot;,    age: 27&#125;</code></pre><p>如上示例，因为 <code>K(nameAndAge)</code> 的类型为 <code>name|age</code> ，所以通过 <code>Pick&lt;Person,nameAndAge&gt;</code> 得到的类型是 <code>&#123; name:string , age:number &#125;</code> 。</p><p>##Record</p><pre><code>/** * Construct a type with a set of properties K of type T * 将联合类型K的所有值作为Key，T作为类型，生成一个新的类型 */type Record&lt;K extends keyof any, T&gt; = &#123;    [P in K]: T;&#125;;</code></pre><p>同样的根据 <code>K extends keyof any</code> 我们可以知道 <code>K</code> 是个联合类型，通过 <code>[P in K]</code> 将联合类型的所有值都取了出来，再将其和 <code>T</code> 关联起来，最后返回了一个新的 <code>interface</code> 类型，这个类型里面的所有属性的类型都是 <code>T</code> 类型。</p><pre><code>interface Person &#123;    name: string,    age: number,    sex: string&#125;type TeacherAndWorker = &quot;teacher&quot; | &quot;worker&quot;const person: Record&lt;TeacherAndWorker, Person&gt; = &#123;    teacher: &#123; name: &#39;zl&#39;, age: 27, sex: &quot;M&quot; &#125;,    worker: &#123; name: &#39;zl&#39;, age: 27, sex: &quot;M&quot; &#125;&#125;</code></pre><p>如上示例可以看出，<code>Record</code> 的作用就是将 <code>K(TeacherAndWorker)</code> 的所有子类型作为 <code>新interface</code> 子属性的 <code>key</code> ，将 <code>T(Person)</code> 作为 <code>新interface</code> 所有子属性的值。</p><p>##Exclude</p><pre><code>/** * Exclude from T those types that are assignable to U * 从T中排除可分配给U的类型 */type Exclude&lt;T, U&gt; = T extends U ? never : T;</code></pre><p><code>Exclude</code> 最常用的还是结合两个联合类型来使用的，我们能通过 <code>Exclude</code> 取出 <code>T</code> 联合类型在 <code>U</code> 联合类型中没有的子类型。</p><pre><code>interface Person &#123;    name: string,    age: number,    sex: string&#125;interface Alien &#123;    name: string,    age: number&#125;const personKeysExcludeAlienKeys: Exclude&lt;keyof Person, keyof Alien&gt; = &quot;sex&quot;</code></pre><p>如上所示，<code>T(keyof Person = name|age|sex)</code> 联合类型在 <code>U(keyof Alien = name|age)</code> 联合类型中没有的子类型只有 <code>sex</code>，所以通过 <code>Exclude&lt;keyof Person, keyof Alien&gt;</code> 返回的类型就是 <code>sex</code>。下面我们再来看看 <code>interface</code> 之间的 <code>Exclude</code>。</p><pre><code>const alien: Exclude&lt;Alien, Person&gt; = &#123;    name: &quot;zl&quot;,    age: 27&#125;    </code></pre><p>可以看到，通过 <code>Exclude&lt;Alien, Person&gt;</code> 我们得到的类型就是 <code>Alien</code> 类型，因为 <code>T(Alien) extends U(Person)</code> 为 <code>false</code> ，所以返回 <code>T(Alien)</code>。这种方式我是想不到什么使用场景。</p><p>##Extract</p><pre><code>/** * Extract from T those types that are assignable to U * 从T中提取可分配给U的类型 */type Extract&lt;T, U&gt; = T extends U ? T : never;</code></pre><p><code>Extract</code> 和 <code>Exclude</code> 是相反的，最常用的还是结合两个联合类型来使用的，我们能通过 <code>Extract</code> 取出 <code>T</code> 联合类型在 <code>U</code> 联合类型中所有重复的子类型。</p><img src="/images/5125944-fc2ef49fbd1c8bfe.png" width="100%"><br><p>如图所示，此时通过 <code>Extract&lt;keyof Person, keyof Alien&gt;</code> 返回的是联合类型 <code>name|age</code>。</p><p>##Omit</p><pre><code>/** * Construct a type with the properties of T except for those in type K. * 构造一个属性为T的类型，但类型K中的属性除外。 */type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code></pre><p><code>Omit</code> 就是 <code>Pick</code> 和 <code>Exclude</code> 的组合，首先我们可以通过 <code>K extends keyof any</code> 得知 <code>K</code> 为联合类型，然后通过 <code>Exclude&lt;keyof T, K&gt;</code> 我们取出了在联合类型 <code>keyof T</code> 中有，而在 <code>K</code> 中没有的子属性(这里我们假设是 <code>联合类型M</code> )，最后再通过 <code>Pick&lt;T,M&gt;</code> 得到一个新的 <code>interface</code> 类型，这个类型里面只包含了联合类型 <code>M</code> 的所有类型。<em><strong>简单的讲 <code>Omit</code> 就是从类型 <code>T</code> 中取出在 <code>联合类型K</code> 中所没有的类型。</strong></em></p><pre><code>interface Person &#123;    name: string,    age: number,    sex: string&#125;const person: Omit&lt;Person, &quot;name&quot; | &quot;age&quot;&gt; = &#123; sex: &quot;M&quot; &#125;;</code></pre><p>如上示例，我们取出了在 <code>T(Person)</code> 里面除去 <code>K(&quot;name&quot;|&quot;age&quot;)</code> 以外的类型 <code>sex</code> ，并组成了一个新的 <code>interface</code>。</p><p>##NonNullable</p><pre><code>/** * Exclude null and undefined from T *  从T中剔除null和undefined */type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</code></pre><p>就是字面意思，去除掉联合类型中的 <code>null</code> 和 <code>undefined</code> 类型。如下图所示，</p><img src="/images/5125944-be1bc2dc54865aaa.png" width="100%"><br><p>使用 <code>NonNullable</code> 之后去掉了联合类型 <code>null | undefined | number | string</code> 中的 <code>null</code> 和 <code>undefined</code> 类型，剩下了 <code>number|string</code>。</p><p>##Parameters</p><pre><code> /** * Obtain the parameters of a function type in a tuple * 获取元组中函数类型的参数 */type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;</code></pre><p>根据 <code>&lt;T extends (...args: any) =&gt; any&gt;</code> 我们能够知道 <code>T</code> 是个函数类型，再通过 <code>T extends (...args: infer P) =&gt; any</code> 将 <code>T</code> 的形参列表约束成了泛型 <code>P</code> ，所以通过三元运算返回的是函数类型 <code>T</code> 的形参元组。</p><pre><code>function fn(str: string, num: number) &#123;&#125;type fnParamtersTuple = Parameters&lt;typeof fn&gt;</code></pre><img src="/images/5125944-4d0cac21ce6fafd5.png" width="100%"><br><p>如图所示，<code>fnParamtersTuple</code> 的类型为，<code>fn</code> 的形参类型的元组。</p><p>##ConstructorParameters</p><pre><code>/** * Obtain the parameters of a constructor function type in a tuple * 获取元组中构造函数类型的参数 */type ConstructorParameters&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: infer P) =&gt; any ? P : never;</code></pre><p>和 <code>Parameters</code> 类似，只不过 <code>ConstructorParameters</code> 获取的是构造函数的形参元组。下面以官网上介绍 <code>interface类静态部分与实例部分的区别</code> 中的例子改变一下作为demo。</p><pre><code>interface ClockConstructor &#123;    new(hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123;    tick();&#125;//通过 ConstructorParameters&lt;ClockConstructor&gt; 获取构造函数中的形参元组function createClock(ctor: ClockConstructor, ...arg: ConstructorParameters&lt;ClockConstructor&gt;): ClockInterface &#123;    return new ctor(...arg);&#125;class DigitalClock implements ClockInterface &#123;    constructor(h: number, m: number) &#123; &#125;    tick() &#123;        console.log(&quot;beep beep&quot;);    &#125;&#125;let digital = createClock(DigitalClock, 12, 17);</code></pre><p>##ReturnType</p><pre><code>/** * Obtain the return type of a function type * 获取函数类型的返回类型 */type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</code></pre><p>和 <code>Parameters</code> 类似，只不过 <code>ReturnType</code> 获取的是函数类型的返回类型。</p><pre><code> function fn() : string &#123;     return &quot;&quot; &#125; type fnReturnType = ReturnType&lt;typeof fn&gt;</code></pre><img src="/images/5125944-83e80e5357848ba4.png" width="100%"><br><p>##InstanceType</p><pre><code>/** * Obtain the return type of a constructor function type */type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any;</code></pre><p>和 <code>Parameters</code> 类似，只不过 <code>ConstructorParameters</code> 获取的是构造函数返回值的类型。</p><pre><code>class Person &#123; &#125;class Alien &#123; &#125;type p0 = InstanceType&lt;typeof Person&gt; // Personinterface PersonConstructor &#123;    new(): Person&#125;type p1 = InstanceType&lt;PersonConstructor&gt; // Personinterface PersonAndAlienConstructor &#123;    new(): Person | Alien&#125;type p2 = InstanceType&lt;PersonAndAlienConstructor&gt; // Person | Alien</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#前言&lt;/p&gt;
&lt;p&gt;前面总结了&lt;code&gt;ts&lt;/code&gt;的高级类型，下面再来说说&lt;code&gt;ts&lt;/code&gt;给我们提供的一些基于这些高级类型而成的工具泛型。&lt;/p&gt;
&lt;p&gt;##Partial&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Make all proper</summary>
      
    
    
    
    <category term="TypeScript" scheme="http://example.com/categories/TypeScript/"/>
    
    
    <category term="Advanced Type" scheme="http://example.com/tags/Advanced-Type/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 高级类型</title>
    <link href="http://example.com/2022/11/20/TypeScript-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2022/11/20/TypeScript-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-11-20T03:30:18.000Z</published>
    <updated>2022-11-20T03:50:58.691Z</updated>
    
    <content type="html"><![CDATA[<p>#前言</p><hr><p>之前一直使用的是 <strong>js</strong> 现在转过来学习 <strong>ts</strong> 的时候尝到了 <strong>ts</strong> 对类型规范的很多好处，相应的 <strong>ts</strong> 的类型有时候也让人头大,下面简单总结一下自己对 <strong>ts</strong> 高级类型的学习成果。</p><p>#一般类型</p><hr><pre><code>//给变量指定类型const value: string = &quot;value&quot;//给方法的形参和返回值指定类型const fun0 = (str: string): string =&gt; &#123;    return &quot;&quot;&#125;//甚至可以直接给方法指定类型type funType = (str: string) =&gt; stringconst fun1: funType = (str) =&gt; &#123;    return &quot;&quot;&#125;</code></pre><p>这个时候我们可以看的 <code>fun1</code> 这时候是不用指定 <code>str</code> 的类型的，IDE会自动提示，如下：</p><img src="/images/5125944-2a5d0f6c35cf0f85.png" width="100%"><br><p>但还有个特殊的情况 <code>fun1</code> 的形参是可以不写的，比如：</p><pre><code>type funType = (str: string) =&gt; stringconst fun2: funType = () =&gt; &#123;    return &quot;fun2 return value&quot;&#125;console.log(fun2(&quot;value&quot;));</code></pre><p>这样是不会报错的，可是为什么呢？我们明明指定了<code>funType</code>的形参有且是<code>string</code>，那大家肯定想问真是为什么，抱歉我也不知道，哈哈哈！如果有知道的朋友希望能留言告知。这样做的问题是在<code>fun2</code>里面是拿不到传入的形参的，不知道是不是bug。</p><p>#泛型</p><hr><p>对就是它，我个人来说在学习和使用<code>ts</code>的途中最头疼的就是泛型，<code>ts</code>中泛型的使用真的让人头晕眼花，但当你真的看明白<code>ts</code>中泛型的使用是又不得不说这简直就像是在变魔术。下面记录一下泛型的一般用法：</p><pre><code>//将对象中值为number类型的数据组成一个新对象function getObjAllNum&lt;T&gt;(t: T): any &#123;    let numObj = &#123;&#125; as any;    for (const tKey in t) &#123;        if (typeof t[tKey] == &quot;number&quot;) &#123;            numObj[tKey] = t[tKey]        &#125;    &#125;    return numObj&#125;const value = &#123;    name: &#39;zl&#39;,    age: 27,    sex: &#39;m&#39;&#125;//输出 &#123;age: 27&#125;console.log(getObjAllNum(value));</code></pre><p>可以看到，当我们调用<code>getObjAllNum</code>的时候<code>T</code>类型已经转变成对象<code>value</code>的类型了。</p><img src="/images/5125944-9c713ea3c4d78cfd.png" width="100%"><br><p>#高级类型</p><hr><p>接下来要说的就是<code>ts</code>为我们提供的一些类型的高级操作方式</p><p>##类型别名（type）</p><p>可以理解成可以给一个类型再取另一个名字，比如：</p><pre><code>type myString = stringconst str: myString = &quot;str&quot;</code></pre><p>##联合类型（|）</p><p><code>A|B</code>表示<code>A</code>或者<code>B</code>中的任意一个类型 ，如下代码，<code>zhangSan</code>就是属于<code>Man</code>类型，<code>xiaoLi</code>属于<code>Woman</code>类型。</p><pre><code>interface Man &#123;    working(): void;&#125;interface Woman &#123;    shopping(): void;&#125;type Person = Man | Womanconst zhangSan: Person = &#123;    working() &#123;        console.log(&#39;working&#39;)    &#125;&#125;zhangSan.working()const xiaoLi: Person = &#123;    shopping() &#123;        console.log(&#39;shopping&#39;)    &#125;&#125;xiaoLi.shopping()</code></pre><p>但需要注意的是下面这种写法：</p><pre><code>const person: Person = &#123;    working() &#123;        console.log(&#39;working&#39;)    &#125;,    shopping() &#123;        console.log(&#39;shopping&#39;)    &#125;&#125;</code></pre><p>这样写是不会报错的，但是当试图调用方法的时候就会报错，可以看出调用<code>shopping</code>的时候，就会提示<code>Man</code>不存在<code>shopping</code>属性，其实这是因为<code>A|B</code>联合类型表示的是<code>A</code>或者<code>B</code>中的任意一个类型，只有一个类型，而不是两种类型的合并，下面来说说真正的合并<code>交叉类型（&amp;）</code></p><img src="/images/5125944-7709f5ba1f5db227.png" width="100%"><br><p>##交叉类型（&amp;）</p><p><code>A&amp;B</code>高级类型是将两个类型合并成了一个类型，这个类型拥有<code>A</code>和<code>B</code>的所有属性，所以称其为<code>合并类型</code>也没啥毛病。<strong>这东西才学的时候一直以为是交集，其实应该是并集才对。</strong></p><pre><code>interface Apple &#123;    size: string,    color: string,&#125;interface Pen &#123;    type: string,    color: string,&#125;type Pineapple = Apple &amp; Penconst pineapple: Pineapple = &#123;    size: &#39;大&#39;,    color: &#39;黄色&#39;,    type: &#39;海南凤梨&#39;&#125;</code></pre><p>这里有个问题就是两个<code>Interface</code>做交叉类型时，如果含有相同的<code>key</code>会出现什么问题呢？<a href="https://www.jianshu.com/p/38bc2dac26b5">详情请见另一篇</a>。</p><p>##类型索引（keyof）</p><p><code>keyof</code>的作用是将一个类型拆分开了，将拆分出来的子类型的集合作为类型返回，如下代码，<code>PersonKeys</code>的类型（图<code>keyof.png</code>所示）为<code>name|age</code>这种联合类型</p><pre><code>interface Person &#123;    name: string,    age: number&#125;type PersonKeys = keyof Person</code></pre><img src="/images/5125944-20ef51582f5f8d3a.png" width="100%"><br><p>##类型约束（extends）</p><p><code>extends</code>的作用是约束泛型，将泛型的类型限定成某个类型，如下例子:<code>logPersonInfo&lt;Person&gt;()</code>可以传入<code>Man</code>和<code>Woman</code>两种类型，但<code>logPersonInfo&lt;Man&gt;()</code>却只能传入<code>Man</code>类型,<code>logPersonInfo&lt;Woman&gt;()</code>却只能传入<code>Woman</code>类型。</p><pre><code>interface Person &#123;    name: string,    age: number&#125;class Man implements Person &#123;    name = &#39;zhangSan&#39;;    age = 27;    working() &#123;&#125;&#125;class Woman implements Person &#123;    name = &#39;xiaoLi&#39;;    age = 26;    shopping() &#123;&#125;&#125;function logPersonInfo&lt;T extends Person&gt;(t: T) &#123;    console.log(`name : $&#123;t.name&#125; , age : $&#123;t.age&#125;`)&#125;logPersonInfo&lt;Person&gt;(new Man())logPersonInfo&lt;Person&gt;(new Woman())logPersonInfo&lt;Man&gt;(new Man())logPersonInfo&lt;Woman&gt;(new Woman())</code></pre><p>下面再说一种情况，来更加深入的了解<code>extends</code>:</p><pre><code>interface Person &#123;    name: string,    age: number&#125;class Alien &#123;    name = &quot;E.T&quot;    age = 1000    fly() &#123;    &#125;&#125;function logPersonInfo&lt;T extends Person&gt;(t: T) &#123;    console.log(`name : $&#123;t.name&#125; , age : $&#123;t.age&#125;`)&#125;logPersonInfo&lt;Person&gt;(new Alien())</code></pre><p>这个时候我们传入<code>logPersonInfo&lt;Person&gt;()</code>的是一个<code>Alien</code>，这时候也不会有什么问题，因为<code>Alien</code>包含了<code>Person</code>的所有属性。对比两个例子我们能看得出来这里的<code>extends</code>和类继承的<code>extends</code>是不一样的，这个地方的<code>extends</code>起到的作用只是限制泛型<code>T</code>的类型为包含了<code>Person</code>类型的所有属性（<strong>当然所有属性的类型也要一致</strong>）的类型。</p><p>##类型映射（in）</p><p><code>in</code>高级类型起到的作用是做类型的映射，它会遍历<strong>已有类型的所有key</strong>或者是<strong>联合类型的所有类型</strong>，有点类似于<code>forin</code>。下面我们写的demo，将已有类型的所有属性转换成可空类型。</p><pre><code>interface Person &#123;    name: string;    age: number;&#125;//此时这里的P就是in遍历出来的key//将Person的所有key遍历出来设置成?:可空类型，再赋值上key对应的value//这时候的PersonValueCanNull类型就是所有属性可为空的Person类型了type PersonValueCanNull = &#123; [P in keyof Person]?: Person[P] &#125;</code></pre><p>如上代码，这个时候<code>PersonValueCanNull</code>的类型为<code>&#123;name?: string, age?: number&#125;</code>,如图：</p><img src="/images/5125944-5d14c681a6266115.png" width="100%"><br><p>再来个联合类型的例子：</p><pre><code>type ValueKeyType = &quot;key1&quot; | &quot;key2&quot; | &quot;key3&quot;type ValueType = &#123; [P in ValueKeyType]: boolean &#125;const value: ValueType = &#123;    key1: false,    key2: false,    key3: false,&#125;</code></pre><p>结合上面联合类型的例子，我们再来看第一个例子，<code>[P in keyof Person]</code>就可以拆分成<code>[P in keyof &quot;name&quot;|&quot;age&quot;]</code>，其实最终都是使用联合类型来进行<code>in</code>操作</p><p>##条件类型（A ? B : C）</p><p><code>条件类型</code>其实就是一个三元运算操作，如果满足条件<code>A</code>那么就是<code>B</code>类型，否则就是<code>C</code>类型，话不多说上代码：</p><pre><code>//传入T和U，如果T包含U所有的key，那么返回类型是T，反之返回的是T和U的交叉类型type MergeAction&lt;T, U&gt; = T extends U ? T : T &amp; Uinterface Teacher &#123;    name: string,    age: number,    teachStudentNum: number&#125;interface Father &#123;    name: string,    age: number,    childNum: number&#125;//回顾一下之前的 extends， Teacher里面没有包含Father里面的//所有key，所以返回的是Teacher&amp;Father的交叉类型const person: MergeAction&lt;Teacher, Father&gt; = &#123;    name: &#39;zl&#39;,    age: 27,    teachStudentNum: 60,    childNum: 1&#125;</code></pre><p>类型如图：</p><img src="/images/5125944-b19d136fdd1c9c65.png" width="100%"><br><p>下面我们再来个<code>keyof</code>的例子</p><pre><code>const person :MergeAction&lt;keyof Teacher, keyof Father&gt; = &quot;name&quot;</code></pre><p>此时的类型就是 <code>name|age</code>的<code>联合类型</code>了。<br><img src="/images/5125944-742a495f249e6f45.png" width="100%"><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#前言&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;之前一直使用的是 &lt;strong&gt;js&lt;/strong&gt; 现在转过来学习 &lt;strong&gt;ts&lt;/strong&gt; 的时候尝到了 &lt;strong&gt;ts&lt;/strong&gt; 对类型规范的很多好处，相应的 &lt;strong&gt;ts&lt;/strong&gt; 的类</summary>
      
    
    
    
    <category term="TypeScript" scheme="http://example.com/categories/TypeScript/"/>
    
    
    <category term="Advanced Type" scheme="http://example.com/tags/Advanced-Type/"/>
    
  </entry>
  
  <entry>
    <title>Android 蓝牙搜索，配对，连接发送数据</title>
    <link href="http://example.com/2022/11/20/Android-%E8%93%9D%E7%89%99%E6%90%9C%E7%B4%A2%EF%BC%8C%E9%85%8D%E5%AF%B9%EF%BC%8C%E8%BF%9E%E6%8E%A5%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2022/11/20/Android-%E8%93%9D%E7%89%99%E6%90%9C%E7%B4%A2%EF%BC%8C%E9%85%8D%E5%AF%B9%EF%BC%8C%E8%BF%9E%E6%8E%A5%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/</id>
    <published>2022-11-20T03:26:35.000Z</published>
    <updated>2022-11-20T03:50:13.440Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要在清单配置里面添加两个权限:</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;</code></pre><p>android里面蓝牙是通过BluetoothAdapter来进行操作的，所以首先我们需要获取到BluetoothAdapter的实例</p><pre><code>//先获取BlueToothAdapter的实例BluetoothAdapter blueToothAdapter = BluetoothAdapter.getDefaultAdapter();</code></pre><p>在搜索之前，我们可以先获取与我们配对过的设备</p><pre><code>//获取已经配对过的设备的集合Set&lt;BluetoothDevice&gt; bondedDevices = blueToothAdapter.getBondedDevices()</code></pre><p>但是想要获取到配对过的设备，我们必须是在</p><pre><code>//手机有蓝牙设备并且蓝牙是打开的blueToothAdapter != null &amp;&amp; blueToothAdapter.isEnabled()</code></pre><p>下面我们谈一下蓝牙的<b>打开方式</b>，目前作者知道的方式有3种<br>第一种：</p><pre><code>//强制打开蓝牙blueToothAdapter.enable();</code></pre><p>第二种：</p><pre><code>//会以dialog的形式打开一个activity，并且如果我们通过startActivityForResult的形式的话//还能查看蓝牙是否被打开，或者处理蓝牙被打开之后的操作//如果是result_ok的话那么是打开，反之打开失败startActivityForResult(new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE));</code></pre><p>第三种：</p><pre><code>//设置本地设备可以被其它设备搜索，可被搜索的时间是有限的，最多为300s//效果和第二种类似Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);startActivity(discoverableIntent);</code></pre><p><b>关闭蓝牙</b>我们可以调用</p><pre><code>blueToothAdapter.disable();</code></pre><p>接下来是<b>蓝牙搜索</b><br>首先如果想要开启蓝牙搜索，那么只需要调用</p><pre><code>blueToothAdapter.startDiscovery();</code></pre><p>但是我们该如何接收我们搜索到的设备呢，很明显当然是通过接收广播的形式来接收。所以我们应该自定义一个广播接收器，</p><pre><code>class BluetoothReceiver extends BroadcastReceiver &#123;        @Override        public void onReceive(Context context, Intent intent) &#123;            if (intent.getAction().equals(BluetoothDevice.ACTION_FOUND)) &#123;                Log.e(getPackageName(), &quot;找到新设备了&quot;);                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);            &#125;        &#125;    &#125;</code></pre><p>如上代码，我们可以获取到搜索到的蓝牙设备。我们只需在代码里面注册这个广播接收器，在调用蓝牙的搜索方法，就能够进行蓝牙的搜索了。</p><pre><code>//注册广播IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(BluetoothDevice.ACTION_FOUND);registerReceiver(new BluetoothReceiver(), intentFilter);</code></pre><p>这里需要注意的是，如果你的代码将运行在（Build.VERSION.SDK_INT &gt;= 23）的设备上，那么务必加上以下权限，并在代码中动态的申请权限</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;</code></pre><pre><code>private void requestPermission() &#123;        if (Build.VERSION.SDK_INT &gt;= 23) &#123;            int checkAccessFinePermission = ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION);            if (checkAccessFinePermission != PackageManager.PERMISSION_GRANTED) &#123;                ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.ACCESS_FINE_LOCATION&#125;,                        REQUEST_PERMISSION_ACCESS_LOCATION);                Log.e(getPackageName(), &quot;没有权限，请求权限&quot;);                return;            &#125;            Log.e(getPackageName(), &quot;已有定位权限&quot;);            //这里可以开始搜索操作        &#125;    &#125;    @Override    public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123;        switch (requestCode) &#123;            case REQUEST_PERMISSION_ACCESS_LOCATION: &#123;                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;                    Log.e(getPackageName(), &quot;开启权限permission granted!&quot;);                    //这里可以开始搜索操作                &#125; else &#123;                    Log.e(getPackageName(), &quot;没有定位权限，请先开启!&quot;);                &#125;            &#125;        &#125;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);    &#125;</code></pre><p>再来就是<b>蓝牙的配对</b>，目前楼主采用的是通过反射的形式来调用BluetoothDevice的createBondde()方法，如果我们想监听配对的这个过程，那么我们可以为广播接收器再注册一个action。</p><pre><code>try &#123;      //如果想要取消已经配对的设备，只需要将creatBond改为removeBond       Method method = BluetoothDevice.class.getMethod(&quot;createBond&quot;);       Log.e(getPackageName(), &quot;开始配对&quot;);       method.invoke(device);    &#125; catch (Exception e) &#123;      e.printStackTrace();    &#125;</code></pre><pre><code>//绑定状态发生变化intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);</code></pre><p>广播接收器里面我们可以这样写</p><pre><code>if (intent.getAction().equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) &#123;                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);                switch (device.getBondState()) &#123;                    case BluetoothDevice.BOND_NONE:                        Log.e(getPackageName(), &quot;取消配对&quot;);                        break;                    case BluetoothDevice.BOND_BONDING:                        Log.e(getPackageName(), &quot;配对中&quot;);                        break;                    case BluetoothDevice.BOND_BONDED:                        Log.e(getPackageName(), &quot;配对成功&quot;);                        break;                &#125;&#125;</code></pre><p>再来就是<b>向已经配对的设备发送数据</b><br>发送数据分为服务端和客户端，通过socket来进行消息的交互。</p><p>服务端</p><pre><code>new Thread(new Runnable() &#123;            @Override            public void run() &#123;                InputStream is = null;                try &#123;                    BluetoothServerSocket serverSocket = blueToothAdapter.listenUsingRfcommWithServiceRecord(&quot;serverSocket&quot;, uuid);                    mHandler.sendEmptyMessage(startService);                    BluetoothSocket accept = serverSocket.accept();                    is = accept.getInputStream();                    byte[] bytes = new byte[1024];                    int length = is.read(bytes);                    Message msg = new Message();                    msg.what = getMessageOk;                    msg.obj = new String(bytes, 0, length);                    mHandler.sendMessage(msg);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;).start();</code></pre><p>客户端</p><pre><code>new Thread(new Runnable() &#123;            @Override            public void run() &#123;                OutputStream os = null;                try &#123;                    BluetoothSocket socket = strArr.get(i).createRfcommSocketToServiceRecord(uuid);                    socket.connect();                    os = socket.getOutputStream();                    os.write(&quot;testMessage&quot;.getBytes());                    os.flush();                    mHandler.sendEmptyMessage(sendOver);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;).start();</code></pre><p>可以看到无论是服务端还是客户端，都需要新起一个子线程来操作。那么服务端和客户端是怎么识别对方的呢，那么就需要用到<b>UUID</b>了，只有当服务端和客户端的<b>UUID</b>相同的时候才能够建立连接。</p><p><b>蓝牙连接发送数据的时候的坑</b><br>当博主第一次写好客户端服务端测试的时候，服务端一直报错</p><pre><code>java.io.IOException: bt socket closed, read return: -1</code></pre><p>也就是这句话报错</p><pre><code>is.read(bytes)</code></pre><p>当时一直以为是读取返回值是-1就会报错，但是不对啊，以前这么写也没错过，在网上百度了半天，看了别人的博客论坛也没有解决办法，最后才注意到报错的前一句，</p><pre><code>bt socket closed</code></pre><p>之前一直认为是什么服务端这边，报错连接才会断开，后来一想客户端也会断开连接啊，这才找到问题所在。原来是我当时write完数据之后将连接关闭了，这才导致服务端这边连接断开的。所以重要的事情要说3遍，千万别急着断开连接，千万别急着断开连接，千万别急着断开连接。</p><p><a href="https://github.com/MonkZl/BlueToothDemo">github源代码链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先需要在清单配置里面添加两个权限:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.BLUETOOTH&amp;quot; /&amp;gt;
&amp;lt;uses-permission and</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>item高度动态变化的RecyclerView</title>
    <link href="http://example.com/2022/11/20/item%E9%AB%98%E5%BA%A6%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96%E7%9A%84RecyclerView/"/>
    <id>http://example.com/2022/11/20/item%E9%AB%98%E5%BA%A6%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96%E7%9A%84RecyclerView/</id>
    <published>2022-11-20T03:02:44.000Z</published>
    <updated>2022-11-20T03:50:13.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先来看一下效果图"><a href="#首先来看一下效果图" class="headerlink" title="首先来看一下效果图"></a>首先来看一下效果图</h2><div style="text-align: center; display: flex; justify-content: space-around;">    <div>        <img src="/images/5125944-77e025a2d814f062.gif" width="256" height="256">        <div>linearLayoutManager</div>    </div>    <div>        <img src="/images/5125944-a03770304bb1a3f1.gif" width="256" height="256">        <div>gridLayoutManager</div>    </div></div><br><p>首先可以确定的是每个item肯定是有最大高度和最小高度的，所以我们先要给定item的目标高度（targetHeight）和初始高度（defaultHeight）。<br></br><br>就以LinearLayoutManager和targetHeight大于defaultHeight为例，都是第一排的item往上滑动的时候item高度是减小的，但是第二排的item的高度是增加的，很明显的能看出当我们滑动的时候，列表滑动是很流畅的，不难看出第一排item高度的减小和第二排item高度的增加是守恒的，也就是说这两个高度相加是一直等于targetHeight+defaultHeight的，所有我们只需要确定了第一个item的高度那么第二个item的高度就等于targetHeight+defaultHeight-第一个item的高度。<br></br><br>那么第一个item的高度要怎么确定呢，理论上这个top绝对值的的最大值是defaultheight,因为当第一个item快要完全划出去的时候我们通过getTop获取到的高度就应该是defaultHeight，而且第一个item就应该根据top的变化来动态的改变自己的高度，而top绝对值变化的范围就是在targetHeight和defaultHeight之间的，那么根据高度的变化就等于(top * 1f / defaultHeight) * (targetHeight - defaultHeight)，再通过和targetHeight求和就得到了第一个item的高度了，可以看出第一个item高度的范围，当top为0的时候是targetHeight，当top为-targetHeight的时候（不难看出第一个item的top值一直是小于等于0的）是defaultHeight。</p><pre><code>View childAt0 = getChildAt(0);ViewGroup.LayoutParams layoutParams0 = childAt0.getLayoutParams();int top = childAt0.getTop();top = top &lt;= -defaultHeight ? -defaultHeight : top;layoutParams0.height = (int) (targetHeight + (top * 1f / defaultHeight) * (targetHeight - defaultHeight));childAt0.requestLayout();</code></pre><p>那么第二个item的高度确定的方法上面也说了，就是等于总高度减去第一个item的高度。</p><pre><code>View childAt1 = getChildAt(1);ViewGroup.LayoutParams layoutParams1 = childAt1.getLayoutParams();layoutParams1.height = defaultHeight + targetHeight - getChildAt(0).getLayoutParams().height;childAt1.requestLayout();</code></pre><p>接下来的item高度就好确定了，都是defaultHeight。</p><pre><code>View childAt = getChildAt(i);ViewGroup.LayoutParams layoutParams = childAt.getLayoutParams();layoutParams.height = defaultHeight;childAt.requestLayout();</code></pre><h2 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h2><p>如果用户滑动速度比较慢，那么top的绝对值一直是小于等于defaultHeight的，但是当用户快速滑动的时候top的绝对值就会出现比defaultHeight大的情况，这个bug目前还不知道是怎么产生的（如果有大佬知道，希望大佬给点意见）,所以目前先在第一个item确定高度的地方加上了</p><pre><code>top = top &lt;= -defaultHeight ? -defaultHeight : top;</code></pre><p>这个判断避免出现top绝对值大于defaultHeight 的情况。</p><p><a href="https://github.com/MonkZl/FreeStyleRecyclerViewDemo">github源代码链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;首先来看一下效果图&quot;&gt;&lt;a href=&quot;#首先来看一下效果图&quot; class=&quot;headerlink&quot; title=&quot;首先来看一下效果图&quot;&gt;&lt;/a&gt;首先来看一下效果图&lt;/h2&gt;&lt;div style=&quot;text-align: center; display: flex</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>intentFilter的匹配规则</title>
    <link href="http://example.com/2022/11/20/intentFilter%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>http://example.com/2022/11/20/intentFilter%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</id>
    <published>2022-11-20T02:10:58.000Z</published>
    <updated>2022-11-20T03:50:13.434Z</updated>
    
    <content type="html"><![CDATA[<p>在说明intentFilter之前首先需要介绍一下Activity的启动方式，分为显示启动和隐式启动。</p><h2 id="显示启动"><a href="#显示启动" class="headerlink" title="显示启动"></a>显示启动</h2><pre><code>//显示启动只需要添加一个context对象和一个类对象就行了Intent intent = new Intent(MainActivity.this, ActivityData.class);startActivity(intent);</code></pre><h2 id="隐式启动"><a href="#隐式启动" class="headerlink" title="隐式启动"></a>隐式启动</h2><p>说到隐式启动就要谈到intentFilter的匹配了,下面这段在配置文件里面的activity的intent-filter,如果我们想要通过隐式启动的方式打开这个activity，那么就需要为intent<b>指定</b>action，<b>添加</b>category，<b>指定</b>data</p><pre><code>&lt;intent-filter&gt;                &lt;action android:name=&quot;action&quot; /&gt;                &lt;action android:name=&quot;action_copy&quot;/&gt;                &lt;category android:name=&quot;category&quot; /&gt;                &lt;category android:name=&quot;category_copy&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;                &lt;data                    android:mimeType=&quot;text/plain&quot;                    android:host=&quot;zl&quot;                    android:path=&quot;/zl/mon&quot;                    android:port=&quot;8080&quot;                    android:scheme=&quot;http&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>下面贴出通过隐式启动的方式打开该activity的方法</p><pre><code>Intent intent = new Intent();intent.setAction(&quot;action&quot;);intent.addCategory(&quot;category&quot;);intent.setDataAndType(Uri.parse(&quot;http://zl:8080/zl/mon&quot;),&quot;text/plain&quot;);startActivity(intent);</code></pre><h2 id="Action的匹配规则"><a href="#Action的匹配规则" class="headerlink" title="Action的匹配规则"></a>Action的匹配规则</h2><p>其实关于action的匹配规则可以在上面通过隐式启动activity的方式中看出，是为intent<b>设置</b>action(<b>intent.setAction(“action”)</b>)，所以<b>只需要设置的action和配置文件中的某一个<action />匹配就行了</b>。</p><h2 id="Category的匹配规则"><a href="#Category的匹配规则" class="headerlink" title="Category的匹配规则"></a>Category的匹配规则</h2><p>同理category的匹配规则，也能通过上述的代码来理解，可以看出为intent设置category的方法是<b>intent.addCategory(“category”)</b>,很明显的能明白是添加category，那么category的匹配方式就是<b>已添加的category必须是清单文件里面有的category</b>。</p><h2 id="Category的坑"><a href="#Category的坑" class="headerlink" title="Category的坑"></a>Category的坑</h2><p>可以看到，在上面category里面有</p><pre><code> &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</code></pre><p>而我们也没有在代码里面设置它，那么我们是不是可以在清单配置文件里面把它删除了呢。大家可以试试，如果删除，再次打开activity的时候就会报错。<br>其实原理很简单，因为<b>这个category系统已经默认的帮我们把它添加到intent里面了</b>，所以当打开activity的时候，系统就去匹配category，发现系统默认帮我们添加的</p><pre><code> &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</code></pre><p>属性并不存在，那么当然就无法匹配成功啦。</p><h2 id="Data的匹配规则"><a href="#Data的匹配规则" class="headerlink" title="Data的匹配规则"></a>Data的匹配规则</h2><pre><code>&lt;data          android:mimeType=&quot;text/plain&quot;          android:host=&quot;zl&quot;          android:path=&quot;/zl/mon&quot;          android:port=&quot;8080&quot;          android:scheme=&quot;http&quot; /&gt;</code></pre><pre><code>intent.setDataAndType(Uri.parse(&quot;http://zl:8080/zl/mon&quot;),&quot;text/plain&quot;);</code></pre><p>简单的说data就相当于一个网址的拼接，并且还指定了一个type，拼接方式大致如下:</p><pre><code>scheme://host:port/[path|pathPattern|pathPrefix]</code></pre><pre><code>http://zl:8080/zl/mon</code></pre><p><b>path</b>：表示的是完整的一个路径，如上面的/zl/mon。<br><b>pathPattern</b>：也表示完整的路径，但是它里面可以包含通配符，如 “.” 代表”a”,”b”等，”*“ 代表复数，比如”a*“，能匹配 “a” ,”aa” 等。<br><b>pathPrefix</b>：表示路径的前缀信息,将pathPrefix设置成/zl就能进行匹配了。</p><p>这里需要注意的是，data没有默认参数，而且port，path，pathPattern，pathPrefix等参数只有在scheme和host设置了的情况下才有效。</p><p>还有需要注意的是下面两段代码是等同的</p><pre><code>&lt;data                    android:host=&quot;zl&quot;                    android:mimeType=&quot;text/plain&quot;                    android:path=&quot;/zl/mon&quot;                    android:port=&quot;8080&quot;                    android:scheme=&quot;http&quot; /&gt;</code></pre><pre><code>&lt;data                    android:host=&quot;zl&quot;                    android:mimeType=&quot;text/plain&quot;                   /&gt;&lt;data                    android:path=&quot;/zl/mon&quot;                    android:port=&quot;8080&quot;                    android:scheme=&quot;http&quot; /&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在说明intentFilter之前首先需要介绍一下Activity的启动方式，分为显示启动和隐式启动。&lt;/p&gt;
&lt;h2 id=&quot;显示启动&quot;&gt;&lt;a href=&quot;#显示启动&quot; class=&quot;headerlink&quot; title=&quot;显示启动&quot;&gt;&lt;/a&gt;显示启动&lt;/h2&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
</feed>
